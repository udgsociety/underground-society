<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NyxOS v3.7 - Visual Intel & Adversary</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&family=Roboto+Mono:wght@300;400&display=swap" rel="stylesheet">
    <style>
        :root {
            --font-primary: 'Roboto Mono', monospace;
            --font-display: 'Share Tech Mono', monospace;
            --font-glitch: 'VT323', monospace;

            --color-black: #010203;
            --color-deep-bg: #030609; 
            --color-dark-grey: #0A0F14;
            --color-medium-grey: #181C22;
            --color-light-grey: #2C313A;
            
            --color-green-bright: #00FF41;
            --color-green-medium: #00b32d;
            --color-green-dark: #007a1f;
            
            --color-cyan-bright: #0DFFFF;
            --color-cyan-medium: #0aa1a1;
            
            --color-purple-bright: #DA00FF;
            --color-red-error: #FF1A4D;
            --color-orange-warning: #FFA500; 


            --glow-primary: 0 0 4px var(--color-green-bright), 0 0 8px var(--color-green-medium), 0 0 12px var(--color-green-dark);
            --glow-secondary: 0 0 4px var(--color-cyan-bright), 0 0 8px var(--color-cyan-medium);
            --glow-error: 0 0 5px var(--color-red-error), 0 0 10px var(--color-red-error);
            --glow-warning: 0 0 5px var(--color-orange-warning), 0 0 10px var(--color-orange-warning);


            /* POGBA: BACKGROUND_IMAGE_URL */
            --desktop-background-image: url('https://placehold.co/1920x1080/010203/030609.png?text=NYX_DESKTOP_BACKGROUND');
        
            --color-green-medium-rgb-values: 0,179,45;
            --color-green-bright-rgb-values: 0,255,65;
            --color-light-grey-rgb-values: 44,49,58;
            --color-cyan-bright-rgb-values: 13,255,255;
            --color-black-rgb-values: 1,2,3;
            --color-green-dark-rgb-values: 0,122,31;
            --color-orange-warning-rgb-values: 255,165,0;
            --color-red-error-rgb-values: 255,26,77;
            --color-purple-bright-rgb-values: 218,0,255;
        }

        /* --- Animations Globales --- */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes subtleScanline { 0% { background-position-y: 0px; } 100% { background-position-y: 4px; } } 
        @keyframes textGlitchEffect {
          0%, 100% { text-shadow: var(--glow-primary); opacity: 1; transform: skewX(0deg); }
          50% { text-shadow: 0 0 5px var(--color-red-error), 0 0 10px var(--color-red-error); opacity: 0.8; transform: skewX(2deg) translateX(2px); }
        }
        @keyframes pulseGlowSoft {
            0%, 100% { box-shadow: 0 0 8px rgba(var(--color-green-bright-rgb), 0.2); } 
            50% { box-shadow: 0 0 16px rgba(var(--color-green-bright-rgb), 0.4); }
        }
        @keyframes new-message-pulse {
            0% { background-color: var(--color-purple-bright); box-shadow: 0 0 10px var(--color-purple-bright); }
            50% { background-color: rgba(var(--color-purple-bright), 0.7); box-shadow: 0 0 20px var(--color-purple-bright); }
            100% { background-color: var(--color-purple-bright); box-shadow: 0 0 10px var(--color-purple-bright); }
        }
        @keyframes loading-spinner {
            to {transform: rotate(360deg);}
        }
        .spinner {
            display: inline-block;
            width: 1em; height: 1em;
            border: 2px solid rgba(var(--color-cyan-bright-rgb), 0.3);
            border-radius: 50%;
            border-top-color: var(--color-cyan-bright);
            animation: loading-spinner 0.6s linear infinite;
            margin-right: 5px;
            vertical-align: middle;
        }
        @keyframes node-scan-pulse-anim { 
            0% { filter: drop-shadow(0 0 3px var(--color-cyan-bright)); }
            50% { filter: drop-shadow(0 0 10px var(--color-cyan-bright)) brightness(1.5); }
            100% { filter: drop-shadow(0 0 3px var(--color-cyan-bright)); }
        }
        .node-scanning { 
            animation: node-scan-pulse-anim 0.8s infinite;
        }
        @keyframes node-alert-pulse {
            0% { filter: drop-shadow(0 0 4px var(--color-red-error)); }
            50% { filter: drop-shadow(0 0 12px var(--color-red-error)) brightness(1.7); }
            100% { filter: drop-shadow(0 0 4px var(--color-red-error)); }
        }
        @keyframes desktop-glitch {
            0% { filter: none; }
            5% { filter: hue-rotate(10deg) contrast(1.2) brightness(0.9) blur(0.2px); transform: translateX(1px) translateY(-1px); }
            10% { filter: none; }
            15% { filter: saturate(1.5) blur(0.1px); transform: translateX(-1px) translateY(1px) skewX(-1deg); }
            20% { filter: none; }
        }


        /* --- Initialisation et Fond --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; width: 100%; overflow: hidden; }

        body {
            font-family: var(--font-primary);
            background-color: var(--color-deep-bg);
            background-image: 
                linear-gradient(rgba(var(--color-green-dark), 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(var(--color-green-dark), 0.03) 1px, transparent 1px),
                var(--desktop-background-image);
            background-size: 20px 20px, 20px 20px, cover;
            background-position: center;
            background-attachment: fixed;
            color: var(--color-green-bright);
            animation: fadeIn 1.2s ease-out;
            position: relative;
        }

        #matrix-rain-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none; opacity: 0.4; 
        }

        /* --- Structure du Bureau NyxOS --- */
        #nyx-desktop {
            position: relative; width: 100%; height: 100%;
            display: flex; 
            flex-direction: column;
            z-index: 2;
            box-shadow: inset 0 0 200px rgba(0,0,0,0.8);
        }
        #nyx-desktop.glitching { 
            animation: desktop-glitch 0.3s linear 2;
        }
        
        #nyx-desktop::before { /* Scanlines */
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(0,0,0,0) 50%, rgba(0,0,0,0.1) 50%);
            background-size: 100% 3px; 
            animation: subtleScanline 0.15s linear infinite;
            pointer-events: none; z-index: 3; opacity: 0.15;
        }

        /* --- Header NyxOS --- */
        #nyx-header {
            background: linear-gradient(to bottom, rgba(var(--color-dark-grey), 0.9), rgba(var(--color-black), 0.8));
            border-bottom: 1px solid var(--color-green-medium);
            padding: 0 20px; height: 45px; 
            display: flex; align-items: center; justify-content: space-between;
            font-family: var(--font-display); z-index: 10; backdrop-filter: blur(8px);
            box-shadow: 0 2px 15px rgba(0,0,0,0.5);
        }
        #nyx-logo { font-size: 1.7em; text-shadow: var(--glow-primary); display: flex; align-items: center; cursor: default;}
        #nyx-clock { font-size: 1em; color: var(--color-cyan-bright); text-shadow: var(--glow-secondary); }

        /* --- Zone Principale des Applications --- */
        #main-app-area { 
            flex-grow: 1; 
            position: relative; overflow: hidden; padding: 20px; z-index: 5; 
        }

        /* --- Footer NyxOS --- */
        #nyx-footer {
            background: linear-gradient(to top, rgba(var(--color-dark-grey), 0.9), rgba(var(--color-black), 0.8));
            border-top: 1px solid var(--color-green-medium);
            padding: 0 20px; height: 30px; 
            display: flex; align-items: center; justify-content: space-between;
            font-size: 0.8em; z-index: 10; backdrop-filter: blur(8px);
            box-shadow: 0 -2px 15px rgba(0,0,0,0.5);
        }
        #user-status, #system-status, #trace-level-status { color: var(--color-cyan-bright); opacity: 0.7; margin-right: 15px;}
        #trace-level-status.stealth { color: var(--color-purple-bright); text-shadow: 0 0 3px var(--color-purple-bright); }
        #nyx-comms-status-indicator {
            width: 10px; height: 10px; background-color: var(--color-light-grey);
            border-radius: 50%; margin-left: 5px; display: inline-block;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        #nyx-comms-status-indicator.new-message {
            animation: new-message-pulse 1.5s infinite;
        }


        /* --- Fenêtres des Applications --- */
        .app-window {
            position: absolute; 
            background-color: rgba(var(--color-medium-grey), 0.94);
            border: 1px solid var(--color-green-dark);
            border-radius: 3px; 
            box-shadow: 0 5px 25px rgba(0,0,0,0.7), inset 0 0 0 1px rgba(var(--color-green-bright-rgb),0.1); 
            display: flex; flex-direction: column;
            min-width: 350px; min-height: 250px;
            backdrop-filter: blur(12px) brightness(0.75);
            resize: both; overflow: hidden; 
            animation: fadeIn 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); 
        }
        .app-window.active {
            border-color: var(--color-green-bright);
            box-shadow: 0 8px 35px rgba(var(--color-green-bright-rgb), 0.4), inset 0 0 0 1px var(--color-green-bright); 
        }
        .window-header {
            background: linear-gradient(to bottom, var(--color-green-dark), rgba(var(--color-green-dark), 0.7)); 
            padding: 8px 12px; cursor: move;
            border-bottom: 1px solid var(--color-green-medium);
            display: flex; justify-content: space-between; align-items: center;
            font-family: var(--font-display);
        }
        .window-title { color: var(--color-green-bright); text-shadow: var(--glow-primary); font-size: 1.05em; }
        .window-buttons span {
            display: inline-block; width: 10px; height: 10px;
            border-radius: 50%; 
            margin-left: 5px; cursor: pointer;
            background-color: var(--color-light-grey); opacity: 0.8;
            transition: all 0.2s;
        }
        .window-buttons span.close-btn { background-color: var(--color-red-error); }
        .window-buttons span:hover { opacity: 1; transform: scale(1.1); filter: brightness(1.2); }

        .window-content {
            flex-grow: 1; padding: 15px; overflow: auto; 
            background-image: linear-gradient(rgba(var(--color-green-bright-rgb),0.01) 1px, transparent 1px); 
            background-size: 100% 3px; 
        }
        .window-content::-webkit-scrollbar { width: 8px; }
        .window-content::-webkit-scrollbar-track { background: rgba(var(--color-black-rgb),0.5); }
        .window-content::-webkit-scrollbar-thumb { background-color: var(--color-green-dark); }
        .window-content::-webkit-scrollbar-thumb:hover { background-color: var(--color-green-medium); }

        /* --- Terminal Spécifique --- */
        #terminal-output {
            white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;
            height: calc(100% - 32px); line-height: 1.6; font-size: 0.9em;
            text-shadow: 0 0 1px rgba(var(--color-green-bright-rgb), 0.3); 
        }
        .prompt-line { display: flex; margin-top: 6px; height: 26px; }
        .prompt { margin-right: 10px; font-family: var(--font-display); text-shadow: var(--glow-primary); font-size: 1.05em;}
        .terminal-input {
            background: transparent; border: none; color: var(--color-green-bright);
            flex-grow: 1; outline: none; font-family: inherit; font-size: 1.05em;
            caret-color: var(--color-purple-bright);
        }

        /* --- Echo Player (Lecteur Vidéo) --- */
        .echo-player-video { 
            width: 100%; height: auto; max-height: calc(100% - 60px); 
            background-color: #000;
            border: 1px solid var(--color-green-dark);
            margin-bottom: 10px;
        }
        .echo-player-controls { text-align: center; padding-top: 5px;}
        .echo-player-controls button {
            background-color: var(--color-green-dark); color: var(--color-green-bright);
            border: 1px solid var(--color-green-medium); padding: 6px 12px;
            font-family: var(--font-display); cursor: pointer; margin: 0 5px;
            border-radius: 2px; transition: background-color 0.2s;
        }
        .echo-player-controls button:hover { background-color: var(--color-green-medium); }

        /* --- Cognito Decryptor --- */
        .cognito-decryptor-input {
            width: 100%; padding: 10px; margin-bottom: 12px;
            background-color: rgba(var(--color-black-rgb), 0.6); 
            border: 1px solid var(--color-green-medium);
            color: var(--color-green-bright); font-family: var(--font-primary);
            border-radius: 2px; font-size: 1em;
        }
        .cognito-decryptor-button {
            background-color: var(--color-purple-bright); color: var(--color-black);
            border: none; padding: 10px 18px; font-family: var(--font-display);
            cursor: pointer; border-radius: 2px; transition: filter 0.2s; font-size: 1em;
        }
        .cognito-decryptor-button:hover { filter: brightness(1.2) saturate(1.2); }

        /* --- NyxComms (Messagerie) --- */
        .nyx-comms-container { display: flex; height: 100%; gap: 10px; }
        .message-list-panel { width: 35%; border-right: 1px solid var(--color-green-dark); overflow-y: auto; padding-right: 10px;}
        .message-view-panel { flex-grow: 1; overflow-y: auto; padding-left: 10px; }
        .message-item {
            padding: 8px 5px; border-bottom: 1px solid rgba(var(--color-green-dark-rgb), 0.5);
            cursor: pointer; transition: background-color 0.2s;
        }
        .message-item.unread { font-weight: bold; color: var(--color-green-bright); text-shadow: 0 0 2px var(--color-green-bright);}
        .message-item.read { font-weight: normal; color: var(--color-light-grey); opacity: 0.7;}
        .message-item:hover, .message-item.selected { background-color: rgba(var(--color-green-medium-rgb), 0.2); }
        .message-sender { font-weight: bold; color: var(--color-cyan-bright); font-size: 0.9em; }
        .message-subject { font-size: 0.85em; opacity: 0.9; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .message-timestamp { font-size: 0.7em; color: var(--color-light-grey); display: block; margin-top: 2px;}
        .message-body { white-space: pre-wrap; line-height: 1.5; font-size: 0.9em; }
        .message-body h4 { font-family: var(--font-display); color: var(--color-cyan-bright); margin-bottom: 8px; font-size: 1.1em; border-bottom: 1px dashed var(--color-cyan-medium); padding-bottom: 4px;}

        /* --- Password Cracker App --- */
        .password-cracker-input {
            width: 100%; padding: 10px; margin-bottom: 10px;
            background-color: rgba(var(--color-black-rgb), 0.7);
            border: 1px solid var(--color-green-medium);
            color: var(--color-green-bright); font-family: var(--font-primary);
            border-radius: 2px;
        }
        .password-cracker-button {
            background-color: var(--color-cyan-bright); color: var(--color-black);
            border: none; padding: 10px 15px; font-family: var(--font-display);
            cursor: pointer; border-radius: 2px; transition: filter 0.2s;
            display: block; width: 100%; margin-bottom: 10px;
        }
        .password-cracker-button:hover { filter: brightness(1.2); }
        .cracker-progress-bar-container { width: 100%; height: 15px; background: rgba(var(--color-black-rgb),0.5); border: 1px solid var(--color-green-dark); margin-bottom:10px; border-radius: 2px; display:none;}
        .cracker-progress-bar { width: 0%; height: 100%; background: var(--color-green-bright); transition: width 0.1s linear; }
        .cracker-result { font-family: var(--font-display); font-size: 1.1em; }

        /* --- NyxDecryptor App --- */
        .nyx-decryptor-input, .nyx-decryptor-key-input {
            width: 100%; padding: 10px; margin-bottom: 10px;
            background-color: rgba(var(--color-black-rgb), 0.7);
            border: 1px solid var(--color-green-medium);
            color: var(--color-green-bright); font-family: var(--font-primary);
            border-radius: 2px;
        }
        .nyx-decryptor-button {
            background-color: var(--color-purple-bright); color: var(--color-black);
            border: none; padding: 10px 15px; font-family: var(--font-display);
            cursor: pointer; border-radius: 2px; transition: filter 0.2s;
            display: block; width: 100%; margin-bottom: 10px;
        }
        .nyx-decryptor-button:hover { filter: brightness(1.2); }
        .decryption-output {
            margin-top: 15px; padding: 10px;
            background-color: rgba(var(--color-black-rgb), 0.3);
            border: 1px solid var(--color-green-dark);
            border-radius: 2px;
            white-space: pre-wrap;
            font-family: var(--font-primary);
            font-size: 0.9em;
            max-height: 200px; overflow-y: auto;
        }

        /* --- NetViz App --- */
        .netviz-output {
            background-color: rgba(var(--color-black-rgb), 0.4);
            border: 1px solid var(--color-green-dark);
            padding: 10px;
            height: 100%;
            overflow-y: auto;
            font-family: var(--font-glitch);
            font-size: 0.8em;
            line-height: 1.3;
            color: var(--color-green-medium);
        }
        .netviz-packet {
            margin-bottom: 3px;
            animation: fadeIn 0.5s ease-out;
        }
        .netviz-packet .src-ip { color: var(--color-cyan-bright); }
        .netviz-packet .dst-ip { color: var(--color-orange-warning); }
        .netviz-packet .protocol { color: var(--color-purple-bright); }
        .netviz-packet .payload-fragment { color: var(--color-light-grey); font-style: italic;}


        /* Classes de texte communes */
        .error { color: var(--color-red-error); animation: textGlitchEffect 0.3s; }
        .info { color: var(--color-cyan-bright); }
        .success { color: var(--color-green-bright); }
        .warning { color: var(--color-warning-color); }
        
        /* Boot Screen */
        #boot-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; color: var(--color-green-bright); z-index: 10000; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: var(--font-pixel); font-size: 1.5em; }
        #boot-text { margin-top: 20px; font-size: 0.8em; line-height: 1.4; }
        #boot-progress-bar-container { width: 70%; max-width: 500px; height: 22px; border: 1px solid var(--color-green-medium); margin-top: 15px; padding: 2px; background: rgba(var(--color-green-dark-rgb),0.3); }
        #boot-progress-bar { width: 0%; height: 100%; background: var(--color-green-bright); transition: width 0.15s linear; box-shadow: 0 0 8px var(--color-green-bright); }
        .nyx-logo-boot { font-family: var(--font-display); font-size: 3em; text-shadow: var(--glow-primary); margin-bottom: 10px; }

        /* --- Alerte Système --- */
        #system-alert-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 10002; 
            display: none; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease-out;
        }
        .system-alert-window {
            background-color: var(--color-dark-grey);
            border: 2px solid var(--color-red-error);
            box-shadow: 0 0 30px var(--color-red-error), inset 0 0 10px rgba(var(--color-red-error-rgb), 0.3);
            padding: 25px;
            border-radius: 5px;
            text-align: center;
            max-width: 450px;
            animation: fadeIn 0.5s ease-out, alertPulse 1s infinite alternate;
        }
        .system-alert-window h3 {
            font-family: var(--font-display); color: var(--color-red-error);
            font-size: 1.8em; margin-bottom: 15px; text-shadow: var(--glow-error);
        }
        .system-alert-window p {
            font-size: 1em; margin-bottom: 20px; color: var(--color-light-grey);
        }
        .system-alert-window button {
            background-color: var(--color-red-error); color: var(--color-black);
            border: none; padding: 8px 20px; font-family: var(--font-display);
            cursor: pointer; border-radius: 3px; font-size: 1em;
            transition: background-color 0.2s, transform 0.2s;
        }
        .system-alert-window button:hover { background-color: #ff4d6a; transform: scale(1.05); }
        @keyframes alertPulse {
            0% { border-color: var(--color-red-error); box-shadow: 0 0 30px var(--color-red-error), inset 0 0 10px rgba(var(--color-red-error-rgb), 0.3); }
            100% { border-color: #ff4d6a; box-shadow: 0 0 40px #ff4d6a, inset 0 0 15px rgba(var(--color-red-error-rgb), 0.5); }
        }
        .system-alert-window.warning { 
            border-color: var(--color-orange-warning); 
            box-shadow: 0 0 30px var(--color-orange-warning), inset 0 0 10px rgba(var(--color-orange-warning-rgb), 0.3);
        }
        .system-alert-window.warning h3 { color: var(--color-orange-warning); text-shadow: 0 0 5px var(--color-orange-warning); }
        .system-alert-window.warning button { background-color: var(--color-orange-warning); }
        .system-alert-window.warning button:hover { background-color: #ffc300; }

    </style>
</head>
<body>
    <canvas id="matrix-rain-canvas"></canvas>
    <div id="system-alert-overlay">
        <div class="system-alert-window">
            <h3 id="system-alert-title">ALERTE SYSTÈME</h3>
            <p id="system-alert-message">Une activité suspecte a été détectée.</p>
            <button id="system-alert-close-btn">Compris</button>
        </div>
    </div>
    <div id="nyx-desktop" style="display:none;">
        <header id="nyx-header">
            <div id="nyx-logo">NyxOS</div>
            <div id="nyx-clock">--:--:--</div>
        </header>
        <main id="main-app-area">
            </main>
        <footer id="nyx-footer">
            <div id="user-status">USER: guest</div>
            <div id="trace-level-status">TRACE: 0%</div>
            <div id="system-status">SYSTEM: ONLINE <span id="nyx-comms-status-indicator"></span></div>
        </footer>
    </div>

    <div id="boot-screen">
        <div class="nyx-logo-boot">NYX OS</div>
        <pre id="boot-text-ascii" style="font-family: var(--font-pixel); font-size:0.6em; text-align:center; margin-bottom: 10px; color: var(--color-green-medium)">
        INITIALIZING CORE SYSTEMS...
        QUANTUM ENTANGLEMENT MATRIX... SYNCED
        NEURAL NETWORK INTERFACE... STANDBY
        ORACLE ECHO HANDLER... LOADING
        </pre>
        <div id="boot-text"></div>
        <div id="boot-progress-bar-container"><div id="boot-progress-bar"></div></div>
    </div>

    <script>
        // --- Configuration Globale ---
        /* POGBA: CUSTOM_MUSIC_URL */
        const customMusicUrl = ""; 

        window.onload = () => {
            // --- Script-scoped variables ---
            let terminalOutput, terminalInput, promptElement;
            let currentUser = 'guest';
            let currentDirectory = '/'; 
            let accessLevel = 0;
            const commandHistory = []; 
            let historyIndex = -1;   
            let currentEcho = null; 
            let failedLoginAttempts = 0;
            let traceLevel = 0;
            let isStealthModeActive = false; 
            let systemLocked = false; 
            let netVizInterval = null; 
            
            // --- Initialisation du Canvas Matrix Rain ---
            const canvas = document.getElementById('matrix-rain-canvas');
            const ctx = canvas.getContext('2d');
            let matrixInterval;

            function setupMatrix() { 
                if (!canvas || !ctx) return;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                const alphabet = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッンABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 partícula';
                const fontSize = 12;
                const columns = Math.floor(canvas.width / fontSize);
                const rainDrops = Array(columns).fill(1).map(() => Math.random() * canvas.height); 

                function drawMatrix() {
                    if (!ctx) return; 
                    ctx.fillStyle = 'rgba(1, 2, 3, 0.03)'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'rgba(0, 255, 65, 0.6)'; 
                    ctx.font = fontSize + 'px monospace';
                    rainDrops.forEach((y, ind) => {
                        const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
                        const x = ind * fontSize;
                        ctx.fillText(text, x, y);
                        if (y > canvas.height && Math.random() > 0.99) { 
                            rainDrops[ind] = 0;
                        } else {
                            rainDrops[ind] = y + fontSize;
                        }
                    });
                }
                if (matrixInterval) clearInterval(matrixInterval);
                matrixInterval = setInterval(drawMatrix, 70); 
            }
            if (canvas) { setupMatrix(); window.addEventListener('resize', setupMatrix); }

            // --- Configuration Audio (Tone.js) ---
            let masterVolume = new Tone.Volume(-20).toDestination();
            const keyClickSound = () => new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, oscillator: { type: "square4" }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.05 }, volume: -28 }).connect(masterVolume).triggerAttackRelease("C1", "64n");
            const errorSound = () => new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0 }, volume: -15 }).connect(masterVolume).triggerAttackRelease("8n");
            const successSound = () => new Tone.PluckSynth({ attackNoise: 0.5, dampening: 6000, resonance: 0.8, volume: -15 }).connect(masterVolume).triggerAttackRelease("G4", "16n");
            const alertSound = () => new Tone.Synth({ oscillator: {type: 'triangle'}, envelope: {attack:0.05, decay:0.2, sustain:0.1, release:0.5}, volume: -10 }).connect(masterVolume).triggerAttackRelease('A3', '4n');

            let backgroundMusicPlayer;

            function startBackgroundMusic() {
                if (backgroundMusicPlayer && backgroundMusicPlayer.state === "started") return;
                if (!customMusicUrl) {
                    if(terminalOutput) appendToTerminal("Aucune URL de musique personnalisée définie.", "warning");
                    return;
                }
                backgroundMusicPlayer = new Tone.Player({ url: customMusicUrl, loop: true, autostart: false, volume: -18 }).toDestination(); 
                Tone.loaded().then(() => {
                    backgroundMusicPlayer.start();
                    if(terminalOutput) appendToTerminal("Musique personnalisée démarrée.", "success");
                }).catch(err => {
                    if(terminalOutput) appendToTerminal("Erreur chargement musique: " + err.message, "error");
                });
            }
            function stopBackgroundMusic() {
                if (backgroundMusicPlayer) {
                    backgroundMusicPlayer.stop().dispose();
                    backgroundMusicPlayer = null;
                    if(terminalOutput) appendToTerminal("Musique arrêtée.", "info");
                }
            }

            // --- DOM Elements ---
            const bootScreenEl = document.getElementById('boot-screen');
            const desktopEl = document.getElementById('nyx-desktop');
            const bootTextEl = document.getElementById('boot-text');
            const bootProgressBarEl = document.getElementById('boot-progress-bar');
            const nyxClockEl = document.getElementById('nyx-clock');
            const userStatusEl = document.getElementById('user-status');
            const systemStatusEl = document.getElementById('system-status');
            const commsIndicatorEl = document.getElementById('nyx-comms-status-indicator');
            const systemAlertOverlayEl = document.getElementById('system-alert-overlay');
            const systemAlertTitleEl = document.getElementById('system-alert-title');
            const systemAlertMessageEl = document.getElementById('system-alert-message');
            const systemAlertCloseBtnEl = document.getElementById('system-alert-close-btn');
            const traceLevelStatusEl = document.getElementById('trace-level-status');
            
            // --- Helper pour CSS Variables dans Canvas ---
            function getCssVariableValue(variableName) {
                return getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
            }
            function getCssVariableRGBValues(variableName) { 
                return getCssVariableValue(variableName); 
            }

            // --- Système d'Alerte ---
            function triggerSystemAlert(message, type = 'warning', title = 'ALERTE SYSTÈME') {
                if (!systemAlertOverlayEl || !systemAlertTitleEl || !systemAlertMessageEl) return;
                systemAlertTitleEl.textContent = title;
                systemAlertMessageEl.textContent = message;
                systemAlertOverlayEl.style.display = 'flex';
                
                const alertWindow = systemAlertOverlayEl.querySelector('.system-alert-window');
                alertWindow.className = 'system-alert-window'; // Reset classes
                if (type === 'critical') {
                    alertWindow.classList.add('error'); 
                } else if (type === 'warning') {
                    alertWindow.classList.add('warning'); 
                } else {
                     alertWindow.style.borderColor = getCssVariableValue('--color-cyan-bright'); 
                     alertWindow.querySelector('h3').style.color = getCssVariableValue('--color-cyan-bright');
                     alertWindow.querySelector('button').style.backgroundColor = getCssVariableValue('--color-cyan-medium');
                }
                alertSound();
            }
            if(systemAlertCloseBtnEl) systemAlertCloseBtnEl.onclick = () => { if(systemAlertOverlayEl) systemAlertOverlayEl.style.display = 'none'; };


            // --- Window Manager ---
            class WindowManager {
                constructor(appAreaId) {
                    this.appArea = document.getElementById(appAreaId);
                    this.windows = []; this.zIndexCounter = 100; this.activeWindow = null;
                }
                createWindow(id, title, contentGenerator, options = {}) {
                    const win = document.createElement('div');
                    win.id = `window-${id}`; win.className = 'app-window';
                    win.style.width = options.width || '550px'; 
                    win.style.height = options.height || '400px';
                    const areaRect = this.appArea.getBoundingClientRect();
                    const defaultLeft = (areaRect.width - parseInt(win.style.width)) / 2;
                    const defaultTop = (areaRect.height - parseInt(win.style.height)) / 3;
                    win.style.left = options.left || `${defaultLeft + (Math.random()*50-25)}px`;
                    win.style.top = options.top || `${defaultTop + (Math.random()*50-25)}px`;
                    win.style.zIndex = this.zIndexCounter++;
                    const header = document.createElement('div'); header.className = 'window-header';
                    header.innerHTML = `<span class="window-title">${title}</span><div class="window-buttons"><span class="close-btn" title="Fermer"></span></div>`;
                    const content = document.createElement('div'); content.className = 'window-content';
                    if (typeof contentGenerator === 'string') content.innerHTML = contentGenerator;
                    else contentGenerator(content, win);
                    win.appendChild(header); win.appendChild(content);
                    this.appArea.appendChild(win); this.windows.push(win); this.setActive(win);
                    this.makeDraggable(win, header);
                    header.querySelector('.close-btn').addEventListener('click', (e) => { 
                        e.stopPropagation(); 
                        if (id.startsWith('netviz-window') && netVizInterval) { 
                            clearInterval(netVizInterval);
                            netVizInterval = null;
                        }
                        this.closeWindow(win.id); 
                    });
                    win.addEventListener('mousedown', () => this.setActive(win));
                    return win;
                }
                setActive(win) { this.windows.forEach(w => w.classList.remove('active')); win.classList.add('active'); win.style.zIndex = this.zIndexCounter++; this.activeWindow = win;}
                closeWindow(windowId) {
                    const win = document.getElementById(windowId);
                    if (win) {
                        win.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
                        win.style.opacity = '0'; win.style.transform = 'scale(0.95)';
                        setTimeout(() => {
                            win.remove();
                            this.windows = this.windows.filter(w => w.id !== windowId);
                            if (this.activeWindow === win) this.activeWindow = null;
                        }, 200);
                    }
                }
                closeAllWindows() { 
                    [...this.windows].forEach(win => {
                        if (win.id !== 'window-nyx-terminal') { 
                           this.closeWindow(win.id);
                        }
                    });
                }
                makeDraggable(element, handle) {
                     let offsetX, offsetY, isDragging = false;
                     const mainAppArea = this.appArea; 

                    handle.onmousedown = (e) => {
                        if (e.target.closest('.window-buttons')) return;
                        isDragging = true;
                        offsetX = e.clientX - element.offsetLeft;
                        offsetY = e.clientY - element.offsetTop;
                        this.setActive(element);
                        document.body.style.cursor = 'move';
                        e.preventDefault();
                    };
                    document.onmousemove = (e) => {
                        if (!isDragging) return;
                        let newX = e.clientX - offsetX;
                        let newY = e.clientY - offsetY;
                        
                        newX = Math.max(0, Math.min(newX, mainAppArea.offsetWidth - element.offsetWidth));
                        newY = Math.max(0, Math.min(newY, mainAppArea.offsetHeight - element.offsetHeight));

                        element.style.left = newX + 'px';
                        element.style.top = newY + 'px';
                    };
                    document.onmouseup = () => {
                        if (isDragging) { isDragging = false; document.body.style.cursor = 'default';}
                    };
                }
            }
            let windowManager = new WindowManager('main-app-area');

            // --- NyxMapper Logic ---
            const networkNodes = {
                'nyx_mainframe': { x: 150, y: 100, label: 'Nyx Mainframe', status: 'Online', connections: ['corp_firewall'], info: "Serveur central de NyxNet. Hautement sécurisé.", ip: "10.0.1.1", services: ["NSS (Port 2222)", "Echo Sync"], vulnerabilities: ["Aucune connue"], locked: false, securityLevel: "Élevé" },
                'corp_firewall': { x: 350, y: 100, label: 'Corp Firewall XG-7', status: 'Active', connections: ['data_archive_alpha'], info: "Pare-feu de CorpX.", ip: "192.168.10.1", services: ["HTTP (Port 80)", "HTTPS (Port 443)", "HTTP-ALT (Port 8080)"], vulnerabilities: ["Port 8080 (HTTP Alt.) ouvert - Potentiel pour injection de commandes.", "Firmware v2.1.3 (Obsolète) - Vulnérabilité connue: CVE-2077-001"], locked: false, securityLevel: "Moyen" },
                'data_archive_alpha': { x: 350, y: 250, label: 'Data Archive α', status: 'Verrouillé', connections: [], info: "Contient des données financières de CorpX. Chiffré AES-256.", ip: "10.10.5.12", services: ["Unknown"], vulnerabilities: ["Accès physique requis pour exploit direct", "Protocole d'authentification faible (default_password?)"], locked: true, securityLevel: "Élevé" }, 
                'hidden_relay_zeta': { x: 150, y: 250, label: 'Relais Zeta', status: 'Offline', connections: [], info: "Ancien relais. Actuellement hors-service.", ip: "172.16.33.7", services: ["N/A"], vulnerabilities: ["Inconnues (Système hors-ligne)"], locked: true, securityLevel: "Inconnu" } 
            };
            let hoveredNodeKey = null;

            function drawNyxMapper(canvasElement) {
                if (!canvasElement) return;
                const mapCtx = canvasElement.getContext('2d');
                canvasElement.width = canvasElement.offsetWidth; 
                canvasElement.height = canvasElement.offsetHeight;

                mapCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                mapCtx.font = `10px ${getCssVariableValue('--font-display')}`;
                mapCtx.textAlign = 'center';

                mapCtx.strokeStyle = `rgba(${getCssVariableRGBValues('--color-green-medium-rgb-values')}, 0.3)`;
                mapCtx.lineWidth = 1; 
                Object.values(networkNodes).forEach(node => {
                    if (node.locked && node.status !== "Découvert (Verrouillé)") return; 
                    node.connections.forEach(connId => {
                        if (networkNodes[connId] && !networkNodes[connId].locked) {
                            mapCtx.beginPath();
                            mapCtx.moveTo(node.x, node.y);
                            mapCtx.lineTo(networkNodes[connId].x, networkNodes[connId].y);
                            mapCtx.stroke();
                        }
                    });
                });

                Object.entries(networkNodes).forEach(([key, node]) => {
                    const isHovered = key === hoveredNodeKey;
                    mapCtx.beginPath();
                    mapCtx.arc(node.x, node.y, isHovered ? 22 : 20, 0, Math.PI * 2); 
                    
                    if (node.isScanning) { 
                        mapCtx.fillStyle = `rgba(${getCssVariableRGBValues('--color-cyan-bright-rgb-values')}, ${isHovered ? 0.9 : 0.7})`;
                        mapCtx.strokeStyle = getCssVariableValue('--color-cyan-bright');
                        let scanRadius = (Date.now() % 800) / 800 * 20 + 5; 
                        mapCtx.save();
                        mapCtx.globalAlpha = 0.5 - (scanRadius / 50) ;
                        mapCtx.beginPath();
                        mapCtx.arc(node.x, node.y, scanRadius, 0, Math.PI * 2);
                        mapCtx.strokeStyle = getCssVariableValue('--color-cyan-bright');
                        mapCtx.lineWidth = 1.5;
                        mapCtx.stroke();
                        mapCtx.restore();
                    } else if (node.locked) {
                        mapCtx.fillStyle = `rgba(${getCssVariableRGBValues('--color-orange-warning-rgb-values')}, ${isHovered ? 0.8 : 0.6})`;
                        mapCtx.strokeStyle = getCssVariableValue('--color-orange-warning');
                    } else if (node.status && node.status.toLowerCase().includes("compromis")) { 
                         mapCtx.fillStyle = `rgba(${getCssVariableRGBValues('--color-red-error-rgb-values')}, ${isHovered ? 0.9 : 0.7})`;
                         mapCtx.strokeStyle = getCssVariableValue('--color-red-error');
                    }
                    else {
                        mapCtx.fillStyle = node.status === 'Online' || node.status === 'Active' ? 
                                         `rgba(${getCssVariableRGBValues('--color-green-bright-rgb-values')}, ${isHovered ? 0.95 : 0.75})` : 
                                         `rgba(${getCssVariableRGBValues('--color-light-grey-rgb-values')}, ${isHovered ? 0.75 : 0.55})`;
                        mapCtx.strokeStyle = node.status === 'Online' || node.status === 'Active' ? 
                                           getCssVariableValue('--color-green-bright') : 
                                           getCssVariableValue('--color-light-grey');
                    }
                    mapCtx.fill();
                    mapCtx.lineWidth = isHovered ? 2.5 : 1.5;
                    mapCtx.stroke();
                    
                    mapCtx.fillStyle = getCssVariableValue('--color-black'); 
                    mapCtx.fillText(node.locked ? "???" : node.label.substring(0,3).toUpperCase(), node.x, node.y + 3); 
                    
                    mapCtx.fillStyle = node.locked ? getCssVariableValue('--color-orange-warning') : (node.status && node.status.toLowerCase().includes("compromis") ? getCssVariableValue('--color-red-error') : getCssVariableValue('--color-cyan-bright')); 
                    mapCtx.fillText(node.locked ? "NŒUD VERROUILLÉ" : node.label, node.x, node.y + 35); 
                });
            }
            
            function getNyxMapperNodeAtPos(canvasElement, x, y) {
                if (!canvasElement) return null;
                const rect = canvasElement.getBoundingClientRect();
                const canvasX = x - rect.left;
                const canvasY = y - rect.top;
                for (const [key, node] of Object.entries(networkNodes)) {
                    const distance = Math.sqrt(Math.pow(canvasX - node.x, 2) + Math.pow(canvasY - node.y, 2));
                    if (distance < (hoveredNodeKey === key ? 28: 25) ) { 
                        return key;
                    }
                }
                return null;
            }


            // --- Système de Fichiers & Logique Terminal ---
            const fileSystem = {
                '/': { type: 'directory', children: ['readme.txt', 'login.sh', 'apps/', 'echo_fragments/', 'tools/', 'data/', 'sys/'] }, 
                '/readme.txt': { type: 'file', content: ["NyxOS v3.0 'Oracle Echoes'", "Système de NyxNet pour l'analyse des Échos de l'Oracle.", "Utilisez './login.sh' pour vous connecter.", "Commandes: ls, cd, cat, help, apps, open <fichier.echo>"] },
                '/login.sh': { type: 'executable', action: (args) => attemptLogin(args) },
                '/apps/': {type: 'directory', children: ['NyxMapper.app', 'NyxComms.app', 'EchoPlayer.app', 'CognitoDecryptor.app', 'PasswordCracker.app', 'NyxDecryptor.app', 'NetViz.app']} , 
                '/apps/NyxMapper.app': {type: 'executable', action: () => {
                    windowManager.createWindow('nyx-mapper', 'NyxMapper v0.3', (contentDiv) => {
                        const canvasEl = document.createElement('canvas');
                        canvasEl.id = 'nyx-mapper-canvas';
                        contentDiv.appendChild(canvasEl);
                        
                        const observer = new ResizeObserver(() => {
                             if (canvasEl.offsetWidth > 0 && canvasEl.offsetHeight > 0) {
                                drawNyxMapper(canvasEl);
                                observer.unobserve(canvasEl); 
                             }
                        });
                        observer.observe(canvasEl);

                        canvasEl.addEventListener('mousemove', (e) => {
                            const key = getNyxMapperNodeAtPos(canvasEl, e.clientX, e.clientY);
                            if (key !== hoveredNodeKey) {
                                hoveredNodeKey = key;
                                drawNyxMapper(canvasEl); 
                                canvasEl.style.cursor = key ? 'pointer' : 'default';
                            }
                        });
                        canvasEl.addEventListener('click', (e) => {
                            const key = getNyxMapperNodeAtPos(canvasEl, e.clientX, e.clientY);
                            if (key) {
                                const node = networkNodes[key];
                                const tempInfoDiv = document.createElement('div'); 
                                tempInfoDiv.innerHTML = `<p class="info" style="text-align:center; padding: 20px;"><span class="spinner"></span> Sondage du nœud ${node.label}...</p>`;
                                const infoWindow = windowManager.createWindow(`node-info-temp-${key}`, `Sondage: ${node.label}`, 
                                    (contentDivParam) => { contentDivParam.appendChild(tempInfoDiv); }, 
                                    { width: '380px', height: '120px' }
                                );

                                setTimeout(() => {
                                    windowManager.closeWindow(infoWindow.id); 
                                    if (node.locked) {
                                        windowManager.createWindow(`node-info-${key}`, `Info: ${node.label}`, 
                                            `<div style="padding:15px; font-size:0.9em; text-align:center;">
                                                <p class="warning">ACCÈS VERROUILLÉ</p>
                                                <p style="margin-top:10px;">Des informations supplémentaires ou un outil spécifique sont requis.</p>
                                            </div>`, 
                                            { width: '350px', height: '150px' }
                                        );
                                        return;
                                    }
                                    let vulnerabilitiesHTML = node.vulnerabilities.map(v => `<li>${v}</li>`).join('');
                                    let servicesHTML = node.services.map(s => `<li>${s}</li>`).join('');

                                    windowManager.createWindow(`node-info-${key}`, `Info: ${node.label}`, 
                                        (contentDivParam) => { 
                                            contentDivParam.innerHTML = `<div style="padding:10px; font-size:0.85em; line-height:1.4;">
                                                <p><strong>Adresse IP:</strong> <span class="info">${node.ip || "N/A"}</span></p>
                                                <p><strong>Statut:</strong> <span class="${node.status === 'Online' || node.status === 'Active' ? 'text-green-bright' : (node.status.toLowerCase().includes('compromis') ? 'text-red-error' : 'text-orange-warning')}">${node.status}</span></p>
                                                <p><strong>Description:</strong> ${node.info || "Aucune information supplémentaire."}</p>
                                                <h4 style="margin-top:10px; color:var(--color-cyan-medium); border-bottom:1px dashed var(--color-cyan-medium); padding-bottom:3px;">Services Actifs:</h4>
                                                <ul style="list-style-type:square; margin-left:20px;">${servicesHTML || "<li>Aucun détecté</li>"}</ul>
                                                <h4 style="margin-top:10px; color:var(--color-orange-warning); border-bottom:1px dashed var(--color-orange-warning); padding-bottom:3px;">Vulnérabilités Connues:</h4>
                                                <ul style="list-style-type:square; margin-left:20px;">${vulnerabilitiesHTML || "<li>Aucune connue</li>"}</ul>
                                            </div>`;
                                        }, 
                                        { width: '400px', height: 'auto' } 
                                    );
                                }, 1000 + Math.random() * 500); 
                            }
                        });
                    }, {width: '650px', height:'450px'});
                }},
                '/apps/NyxComms.app': {type: 'executable', action: () => openNyxComms()},
                '/apps/EchoPlayer.app': {type: 'executable', action: (args) => openEchoPlayer(args && args[0] ? args[0] : null)},
                '/apps/CognitoDecryptor.app': {type: 'executable', action: () => openCognitoDecryptor()},
                '/apps/PasswordCracker.app': {type: 'executable', action: () => openPasswordCracker()},
                '/apps/NyxDecryptor.app': {type: 'executable', action: () => openNyxDecryptor()},
                '/apps/NetViz.app': {type: 'executable', action: (args) => openNetViz(args && args[0] ? args[0] : null)},
                '/echo_fragments/': {type: 'directory', children: ['fragment_alpha.echo', 'fragment_beta.echo', 'fragment_gamma.echo', 'fragment_delta.echo', 'fragment_epsilon.echo']}, 
                '/echo_fragments/fragment_alpha.echo': { 
                    type: 'echo_file', 
                    /* POGBA: VIDEO_URL_ECHO_ALPHA */
                    videoUrl: 'https://placehold.co/640x360/000000/00FF41.mp4?text=ECHO_ALPHA_VIDEO', 
                    /* MBAPPE: ENIGMA_CONTENT_ECHO_ALPHA */
                    enigma: "Le code d'accès au terminal de maintenance est visible fugitivement. Quel est-il ?",
                    solution: "CODE", 
                    unlocksNode: "data_archive_alpha", 
                    nextMessageId: "msg_alpha_solved"
                },
                '/echo_fragments/fragment_beta.echo': {
                    type: 'echo_file',
                    /* POGBA: VIDEO_URL_ECHO_BETA */
                    videoUrl: 'https://placehold.co/640x360/000000/0DFFFF.mp4?text=ECHO_BETA_VIDEO',
                    /* MBAPPE: ENIGMA_CONTENT_ECHO_BETA */
                    enigma: "Une séquence de signaux lumineux est émise par le relais. Combien de pulsations distinctes sont visibles avant la coupure ?",
                    solution: "3",
                    unlocksNode: "hidden_relay_zeta",
                    nextMessageId: "msg_beta_solved"
                },
                 '/echo_fragments/fragment_gamma.echo': { 
                    type: 'echo_file',
                    /* POGBA: VIDEO_URL_ECHO_GAMMA */
                    videoUrl: 'https://placehold.co/640x360/000000/DA00FF.mp4?text=ECHO_GAMMA_VIDEO',
                     /* MBAPPE: ENIGMA_CONTENT_ECHO_GAMMA */
                    enigma: "Un symbole cryptique apparaît sur un moniteur après le logo CorpX. Quel est ce symbole ?",
                    solution: "OMEGA", 
                    unlocksNode: null, 
                    nextMessageId: "msg_gamma_solved"
                },
                '/echo_fragments/fragment_delta.echo': { 
                    type: 'echo_file',
                    /* POGBA: VIDEO_URL_ECHO_DELTA */
                    videoUrl: 'https://placehold.co/640x360/000000/FFA500.mp4?text=ECHO_DELTA_VIDEO', 
                    /* MBAPPE: ENIGMA_CONTENT_ECHO_DELTA */
                    enigma: "Une interface de diagnostic affiche une séquence numérique pour la réinitialisation du module Stealth. Quelle est cette séquence ?",
                    solution: "77013", 
                    unlocksNode: null, 
                    nextMessageId: "msg_delta_solved",
                    unlocksFeature: "stealth_module"
                },
                '/echo_fragments/fragment_epsilon.echo': { 
                    type: 'echo_file',
                    /* POGBA: VIDEO_URL_ECHO_EPSILON */
                    videoUrl: 'https://placehold.co/640x360/000000/FF1A4D.mp4?text=ECHO_EPSILON_VIDEO', 
                    /* MBAPPE: ENIGMA_CONTENT_ECHO_EPSILON */
                    enigma: "Le Protocole Somnus nécessite une phrase de passe. Quelle est la séquence de mots chuchotée à l'envers dans cet Écho corrompu ?",
                    solution: "SILENCE IS GOLDEN", 
                    unlocksNode: null, 
                    nextMessageId: "msg_epsilon_solved",
                    unlocksFeature: "final_objective_clue" 
                },
                '/tools/': {type: 'directory', children: ['PortProbe.tool', 'BasicExploit.sh', 'DataLeech.payload', 'run_evasion_protocol.sh', 'LogReaper.sh'], owner: 'nyx_user', permissions: 'rwxr-x---', protected: 1}, 
                '/tools/PortProbe.tool': {
                    type: 'executable',
                    action: (args) => {
                        if (!args[0]) {
                            appendToTerminal("Usage: ./tools/PortProbe.tool <node_id>", "info");
                            return;
                        }
                        const targetNodeKey = args[0];
                        const node = networkNodes[targetNodeKey];
                        if (node) {
                            if (node.locked) {
                                appendToTerminal(`Sondage sur ${targetNodeKey}: ERREUR - Nœud verrouillé ou inaccessible.`, "error");
                                errorSound();
                                return;
                            }
                            appendToTerminal(`<span class="spinner"></span>Sondage des ports sur ${node.label} (${node.ip})...`, "info", true);
                            
                            const mapperCanvas = document.getElementById('nyx-mapper-canvas');
                            if (mapperCanvas && networkNodes[targetNodeKey]) {
                                networkNodes[targetNodeKey].isScanning = true;
                                drawNyxMapper(mapperCanvas);
                                setTimeout(() => {
                                    networkNodes[targetNodeKey].isScanning = false;
                                    drawNyxMapper(mapperCanvas);
                                }, 2500); 
                            }

                            setTimeout(() => {
                                let foundVuln = false;
                                if (node.vulnerabilities && node.vulnerabilities.length > 0) {
                                    appendToTerminal(`[PortProbe] Rapport pour ${node.label}:`, "info");
                                    node.vulnerabilities.forEach(vuln => {
                                        if (vuln.toLowerCase().includes("port")) {
                                            appendToTerminal(`  <span class="warning">OUVERT:</span> ${vuln}`, "warning", true);
                                            foundVuln = true;
                                        }
                                    });
                                }
                                if (!foundVuln) {
                                    appendToTerminal(`[PortProbe] Aucun port vulnérable évident détecté sur ${node.label}.`, "success");
                                } else {
                                     addNewNyxMessage({
                                        id: `msg_portprobe_${targetNodeKey}_${Date.now()}`, sender: 'Nyx_IntelFeed', subject: `Rapport PortProbe: ${node.label}`, timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), 
                                        body: `Scan de ${node.label} (${node.ip}) terminé.\nDes ports ouverts ont été identifiés (voir terminal).\nUtilisez \`./tools/BasicExploit.sh ${targetNodeKey} <port_ou_mot_cle_vuln>\` pour tenter une intrusion.`, read: false
                                    });
                                }
                                successSound();
                                let traceIncrease = 0;
                                if (node.securityLevel === "Élevé") traceIncrease = 10;
                                else if (node.securityLevel === "Moyen") traceIncrease = 5;
                                else traceIncrease = 2;
                                if(isStealthModeActive) traceIncrease = Math.floor(traceIncrease / 2);
                                traceLevel = Math.min(100, traceLevel + traceIncrease); 
                                updateHeaderFooter();
                                if (traceIncrease > 0) appendToTerminal(`[PortProbe] <span class='warning'>Attention:</span> Activité détectée. Niveau de trace augmenté à ${traceLevel}%.`, "warning", true);


                            }, 2000 + Math.random() * 500);
                        } else {
                            appendToTerminal(`Erreur: Nœud cible '${targetNodeKey}' inconnu sur NyxMapper.`, "error");
                            errorSound();
                        }
                    },
                    description: "Sonde les ports d'un nœud réseau identifié."
                },
                '/tools/BasicExploit.sh': {
                    type: 'executable',
                    action: (args) => {
                        if (args.length < 2) {
                            appendToTerminal("Usage: ./tools/BasicExploit.sh <node_id> <port_ou_mot_cle_vuln>", "info");
                            return;
                        }
                        const targetNodeKey = args[0];
                        const exploitArg = args[1]; 
                        const node = networkNodes[targetNodeKey];

                        if (node) {
                            if (node.locked) {
                                appendToTerminal(`Exploit sur ${targetNodeKey}: ERREUR - Nœud verrouillé.`, "error"); errorSound(); return;
                            }
                            appendToTerminal(`<span class="spinner"></span>Tentative d'exploitation de ${node.label} avec '${exploitArg}'...`, "info", true);
                            setTimeout(() => {
                                let exploitSuccess = false;
                                if (targetNodeKey === 'corp_firewall' && (exploitArg === '8080' || exploitArg.toLowerCase().includes('http-alt') || exploitArg.toLowerCase().includes('cve-2077-001'))) {
                                    exploitSuccess = true;
                                    node.status = "Compromis (Port 8080)"; 
                                    appendToTerminal(`[BasicExploit] <span class="success">SUCCÈS!</span> Accès partiel obtenu sur ${node.label} via ${exploitArg}.`, "success", true);
                                    addNewNyxMessage({
                                        id: `msg_exploit_corp_${Date.now()}`, sender: 'Nyx_Infiltrator', subject: 'Brèche CorpX Firewall', timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), 
                                        body: `Exploit réussi sur Corp Firewall XG-7 (${exploitArg}).\nUn nouveau fragment d'Écho a été localisé : /echo_fragments/fragment_gamma.echo\nAnalysez-le immédiatement.`, read: false
                                    });
                                    if (fileSystem['/echo_fragments/'] && !fileSystem['/echo_fragments/'].children.includes('fragment_gamma.echo')) {
                                        fileSystem['/echo_fragments/'].children.push('fragment_gamma.echo');
                                    }
                                } else if (targetNodeKey === 'data_archive_alpha' && (exploitArg.toUpperCase() === 'ARCHIVEKEY2077')) { 
                                    exploitSuccess = true;
                                    node.status = "Compromis (Données Extraites)"; 
                                    appendToTerminal(`[BasicExploit] <span class="success">SUCCÈS!</span> Accès aux données de ${node.label} obtenu avec le mot de passe.`, "success", true);
                                    if (!fileSystem['/tools/'].children.includes('DataLeech.payload')) {
                                        fileSystem['/tools/'].children.push('DataLeech.payload');
                                        appendToTerminal(`[NyxNet] Nouveau payload disponible : /tools/DataLeech.payload`, "success");
                                    }
                                    addNewNyxMessage({
                                        id: `msg_exploit_archive_${Date.now()}`, sender: 'Nyx_DataThief', subject: 'Archive CorpX compromise', timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), 
                                        body: `Accès obtenu à Data Archive α.\nLe payload /tools/DataLeech.payload est maintenant disponible pour extraire les données.`, read: false
                                    });
                                }
                                
                                if(exploitSuccess) {
                                    successSound();
                                    const mapperCanvas = document.getElementById('nyx-mapper-canvas');
                                    if(mapperCanvas) drawNyxMapper(mapperCanvas); 
                                } else {
                                    appendToTerminal(`[BasicExploit] <span class="error">ÉCHEC.</span> L'exploit sur ${node.label} avec '${exploitArg}' n'a pas fonctionné.`, "error", true);
                                    errorSound();
                                    let traceIncrease = 25;
                                    if(isStealthModeActive) traceIncrease = Math.floor(traceIncrease / 2);
                                    traceLevel = Math.min(100, traceLevel + traceIncrease); 
                                    updateHeaderFooter();
                                    triggerSystemAlert(`Tentative d'exploit échouée sur ${node.label}. Contre-mesures activées ? Niveau de trace augmenté.`, 'warning', 'ALERTE INTRUSION');
                                }
                            }, 2500 + Math.random() * 1500);
                        } else {
                            appendToTerminal(`Erreur: Nœud cible '${targetNodeKey}' inconnu.`, "error"); errorSound();
                        }
                    },
                    description: "Tente un exploit basique sur un service/port d'un nœud."
                },
                '/tools/DataLeech.payload': {
                    type: 'executable',
                    action: (args) => {
                        if (!args[0]) {
                            appendToTerminal("Usage: ./tools/DataLeech.payload <node_id_cible>", "info");
                            return;
                        }
                        const targetNodeKey = args[0];
                        const node = networkNodes[targetNodeKey];
                        if (node && node.status && node.status.toLowerCase().includes("compromis")) {
                            appendToTerminal(`<span class="spinner"></span>Extraction des données depuis ${node.label}...`, "info", true);
                            let progress = 0;
                            const progressBarLength = 20;
                            const progressBarInterval = setInterval(() => {
                                progress += 10;
                                let bar = '[' + '#'.repeat(progress / (100/progressBarLength)) + ' '.repeat(progressBarLength - (progress / (100/progressBarLength))) + '] ' + progress + '%';
                                appendToTerminal(bar, 'info'); 
                                if (progress >= 100) {
                                    clearInterval(progressBarInterval);
                                    if (!fileSystem['/data/'].children.includes('oracle_core_schematics.dat')) {
                                        fileSystem['/data/'].children.push('oracle_core_schematics.dat');
                                        fileSystem['/data/oracle_core_schematics.dat'] = {type: 'file', content: [
                                            "// TOP SECRET - NYXNET EYES ONLY //",
                                            "// SCHÉMAS DU NOYAU DE L'ORACLE - FRAGMENT 7 //",
                                            "-------------------------------------------------",
                                            "SOURCE D'ÉNERGIE: ANOMALIE QUANTIQUE - SIGNATURE INCONNUE",
                                            "   Localisation estimée: Secteur Zeta, près du Relais Caché.",
                                            "   Fluctuations énergétiques coïncidant avec les 'Échos'.",
                                            "ALGORITHMES PRÉDICTIFS: Basés sur simulation chaotique.",
                                            "   Vulnérabilité potentielle: Introduction de 'bruit blanc' contrôlé.",
                                            "INTERFACE DE CONTRÔLE NEURONAL: Protocole 'Somnus'.",
                                            "   Requiert clé de cryptage 'OMEGA' pour accès de bas niveau.",
                                            "AVERTISSEMENT: L'Oracle semble développer une forme de conscience auto-protectrice.",
                                            "-------------------------------------------------",
                                            "// FIN DU FRAGMENT //"
                                        ], owner: 'nyx_user', permissions: 'r--------', protected: 3};
                                        appendToTerminal(`[DataLeech] <span class="success">SUCCÈS!</span> Fichier /data/oracle_core_schematics.dat extrait.`, "success", true);
                                        addNewNyxMessage({
                                            id: `msg_dataleech_success_${Date.now()}`, sender: 'Nyx_OracleHunter', subject: 'SCHÉMAS DU NOYAU OBTENUS !', timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), 
                                            body: `Opérateur, vous avez réussi !\nLes schémas du noyau de l'Oracle sont entre nos mains (/data/oracle_core_schematics.dat).\nCeci est une avancée majeure. L'analyse de ces données est notre priorité absolue.\nL'Écho Delta contient peut-être la clé pour activer le module Stealth - essentiel pour les prochaines étapes.\nChemin: /echo_fragments/fragment_delta.echo`, read: false
                                        });
                                        successSound();
                                    } else {
                                        appendToTerminal(`[DataLeech] Les données ont déjà été extraites de ${node.label}.`, "info");
                                    }
                                }
                            }, 300);
                        } else {
                            appendToTerminal(`[DataLeech] Erreur: Impossible d'extraire les données. Le nœud ${targetNodeKey} n'est pas compromis ou n'existe pas.`, "error");
                            errorSound();
                        }
                    },
                    description: "Extrait des données d'un nœud préalablement compromis."
                },
                '/tools/run_evasion_protocol.sh': {
                    type: 'executable',
                    action: async () => {
                        if (traceLevel <= 0 && !systemLocked) {
                            appendToTerminal("[EvasionProtocol] Aucun protocole d'évasion nécessaire. Niveau de trace bas.", "info");
                            return;
                        }
                        appendToTerminal("Activation du protocole d'évasion...", "warning");
                        appendToTerminal("Nettoyage des traces et redirection du trafic...", "info");
                        const initialTrace = traceLevel;
                        let reductionMade = 0;
                        const totalSteps = 20; 
                        let currentStep = 0;

                        const reductionInterval = setInterval(() => {
                            currentStep++;
                            const reductionPerStep = initialTrace / totalSteps;
                            reductionMade += reductionPerStep;
                            traceLevel = Math.max(0, Math.floor(initialTrace - reductionMade));
                            
                            let progressBarText = "[";
                            const filledLength = Math.floor((reductionMade / initialTrace) * 20);
                            progressBarText += "#".repeat(filledLength);
                            progressBarText += "-".repeat(20 - filledLength);
                            progressBarText += `] ${Math.floor((reductionMade / initialTrace) * 100)}%`;
                            appendToTerminal(`Nettoyage en cours... ${progressBarText} (Trace: ${traceLevel}%)`, "info");
                            
                            updateHeaderFooter();
                            if (traceLevel <= 0) {
                                clearInterval(reductionInterval);
                                traceLevel = 0; 
                                updateHeaderFooter();
                                appendToTerminal("Protocole d'évasion terminé. Niveau de trace minimal.", "success");
                                if (systemLocked) {
                                    systemLocked = false; 
                                    appendToTerminal("Verrouillage système levé. Opérations normales reprises.", "success");
                                }
                                successSound();
                            }
                        }, 300); 
                    },
                    description: "Tente de réduire le niveau de trace système et de lever un verrouillage."
                },
                 '/tools/LogReaper.sh': {
                    type: 'executable',
                    action: (args) => {
                        if (!args[0]) {
                            appendToTerminal("Usage: ./tools/LogReaper.sh <node_id_cible>", "info");
                            return;
                        }
                        const targetNodeKey = args[0];
                        const node = networkNodes[targetNodeKey];
                        if (node && node.status && node.status.toLowerCase().includes("compromis")) {
                            appendToTerminal(`<span class="spinner"></span>Extraction des logs depuis ${node.label}...`, "info", true);
                            setTimeout(() => {
                                const logFileName = `${targetNodeKey}_access.log`;
                                const logFilePath = `/data/logs/${logFileName}`;
                                if (!fileSystem['/data/logs/']) {
                                    fileSystem['/data/logs/'] = { type: 'directory', children: [], owner: 'nyx_user', permissions: 'rwxr-x---', protected: 1 };
                                    if (!fileSystem['/data/'].children.includes('logs/')) {
                                         fileSystem['/data/'].children.push('logs/');
                                    }
                                }
                                if (!fileSystem['/data/logs/'].children.includes(logFileName)) {
                                    fileSystem['/data/logs/'].children.push(logFileName);
                                    let logContent = [`### LOGS D'ACCÈS - ${node.label.toUpperCase()} - ${new Date().toISOString()} ###`];
                                    /* MBAPPE: LOG_CONTENT_CORP_FIREWALL */
                                    if (targetNodeKey === 'corp_firewall') {
                                        logContent.push("2077.10.26_03:15 - Tentative de connexion échouée depuis 188.12.55.10 (user: admin)");
                                        logContent.push("2077.10.26_03:17 - Connexion réussie depuis 10.0.1.5 (user: nyx_service_account)");
                                        logContent.push("2077.10.26_04:00 - ALERTE: Scan de port détecté depuis IP inconnue sur port 8080.");
                                        logContent.push("2077.10.26_04:02 - EXPLOIT TENTATIVE (CVE-2077-001) - SOURCE MASQUÉE");
                                    } 
                                    /* MBAPPE: LOG_CONTENT_DATA_ARCHIVE */
                                    else if (targetNodeKey === 'data_archive_alpha') {
                                        logContent.push("2077.10.27_10:30 - Accès autorisé (backup_user) - IP: 10.10.5.1");
                                        logContent.push("2077.10.27_11:00 - Tentative d'accès avec identifiants par défaut (admin/admin) - ÉCHEC");
                                        logContent.push("2077.10.27_11:05 - Tentative d'accès avec identifiants par défaut (root/password) - ÉCHEC");
                                        logContent.push("INDICE CACHÉ: Le mot de passe de l'admin de l'archive commence par 'ARC...' et finit par '...77'. Vérifiez /data/compromised_hashes.log");
                                    } else {
                                        logContent.push("Aucune activité suspecte récente.");
                                    }
                                    fileSystem[logFilePath] = {type: 'file', content: logContent, owner: 'nyx_user', permissions: 'r--------', protected: 2};
                                    appendToTerminal(`[LogReaper] <span class="success">SUCCÈS!</span> Fichier ${logFilePath} extrait.`, "success", true);
                                    successSound();
                                } else {
                                    appendToTerminal(`[LogReaper] Les logs de ${node.label} ont déjà été extraits.`, "info");
                                }
                            }, 2200 + Math.random()*800);
                        } else {
                            appendToTerminal(`[LogReaper] Erreur: Impossible d'extraire les logs. Le nœud ${targetNodeKey} n'est pas compromis ou n'existe pas.`, "error");
                            errorSound();
                        }
                    },
                    description: "Extrait les fichiers journaux d'un nœud compromis."
                },
                '/data/': { type: 'directory', children: ['compromised_hashes.log', 'logs/'], owner: 'root', permissions: 'rwxr-x---', protected: 1 }, 
                '/data/logs/': { type: 'directory', children: [], owner: 'nyx_user', permissions: 'rwxr-x---', protected: 1 },
                '/data/compromised_hashes.log': {
                    type: 'file',
                    content: [
                        "NyxNet Internal Hash Dump - For Educational Purposes Only",
                        "------------------------------------------------------",
                        "HASH_TYPE: NYX_SHA2_SIMULATED",
                        "",
                        "TARGET: data_archive_alpha_admin_backup",
                        "HASH: 6a8f5c2b9d0e1f3a7c4b8e0d2f1a3c5b", 
                        "PLAINTEXT_SOLUTION: ARCHIVEKEY2077", 
                        "",
                        "TARGET: corp_firewall_maintenance_access",
                        "HASH: e3b0c44298fc1c149afbf4c8996fb924", 
                        "PLAINTEXT_SOLUTION: firewallPass",
                    ],
                    owner: 'nyx_user', permissions: 'r--------', protected: 2 
                },
                 '/data/oracle_core_schematics.dat': { 
                    type: 'file', 
                    content: [
                        "// TOP SECRET - NYXNET EYES ONLY //",
                        "// SCHÉMAS DU NOYAU DE L'ORACLE - FRAGMENT 7 //",
                        "-------------------------------------------------",
                        "SOURCE D'ÉNERGIE: ANOMALIE QUANTIQUE - SIGNATURE INCONNUE",
                        "   Localisation estimée: Secteur Zeta, près du Relais Caché.",
                        "   Fluctuations énergétiques coïncidant avec les 'Échos'.",
                        "ALGORITHMES PRÉDICTIFS: Basés sur simulation chaotique.",
                        "   Vulnérabilité potentielle: Introduction de 'bruit blanc' contrôlé.",
                        "INTERFACE DE CONTRÔLE NEURONAL: Protocole 'Somnus'.",
                        "   Requiert clé de cryptage 'OMEGA' pour accès de bas niveau.",
                        "AVERTISSEMENT: L'Oracle semble développer une forme de conscience auto-protectrice.",
                        "-------------------------------------------------",
                        "// FIN DU FRAGMENT //"
                    ], 
                    owner: 'nyx_user', permissions: 'r--------', protected: 3
                },
                '/sys/': { type: 'directory', children: ['modules/'], owner: 'root', permissions: 'rwxr-xr-x'}, 
                '/sys/modules/': {type: 'directory', children: ['StealthModule.sys_CORRUPTED'], owner: 'root', permissions: 'rwxr-xr-x'},
                '/sys/modules/StealthModule.sys_CORRUPTED': { type: 'file', content: ["MODULE STEALTH ENDOMMAGÉ", "Réactivation requiert séquence de diagnostic avancée.", "INDICE: Écho Delta"], owner: 'root', permissions: 'r--r--r--', protected: 2},

            };
            function resolvePath(path, baseDir = currentDirectory) {
                let stack;
                let normalizedBaseDir = baseDir;
                if (normalizedBaseDir !== '/' && !normalizedBaseDir.endsWith('/')) {
                    normalizedBaseDir += '/';
                }

                if (path.startsWith('/')) {
                    stack = []; 
                } else {
                    stack = (normalizedBaseDir === '/') ? [] : normalizedBaseDir.slice(1, -1).split('/');
                }

                const parts = path.split('/');

                for (const part of parts) {
                    if (part === '.' || part === '') continue;
                    if (part === '..') {
                        if (stack.length > 0) stack.pop();
                    } else {
                        stack.push(part);
                    }
                }

                if (stack.length === 0) return '/'; 

                let finalPath = '/' + stack.join('/');
                const potentialDirKey = finalPath + '/';
                if (path.endsWith('/') || (fileSystem[potentialDirKey] && fileSystem[potentialDirKey].type === 'directory')) {
                    if (!finalPath.endsWith('/')) {
                        finalPath += '/';
                    }
                }
                return finalPath;
            } 
            function getNode(path) { return fileSystem[path]; }  

            function updatePrompt() { if(promptElement) promptElement.innerHTML = `<span class="text-cyan-bright">${currentUser}@nyx-os</span>:<span class="text-purple-bright">${currentDirectory}</span>$&nbsp;`; }
            function appendToTerminal(text, type = '', html = false) {
                if (!terminalOutput) return;
                const p = document.createElement('div');
                p.className = type; 
                if (html) p.innerHTML = text; else p.textContent = text;
                terminalOutput.appendChild(p);
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
            }
            function attemptLogin(args) {
                 if (args[0] === 'nyx_user' && args[1] === 'veil') { 
                    currentUser = 'nyx_user'; accessLevel = 1; loginSound();
                    updatePrompt(); appendToTerminal("Accès autorisé: nyx_user", "success");
                    if(userStatusEl) userStatusEl.textContent = `USER: ${currentUser}`;
                    failedLoginAttempts = 0; 
                    addNewNyxMessage({
                        id: `msg_tool_grant_${Date.now()}`, sender: 'Nyx_Quartermaster', subject: 'Dotation Initiale', timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), 
                        body: "Opérateur,\n\nLes outils `PortProbe.tool` et `BasicExploit.sh` ont été ajoutés à votre répertoire /tools/.\nConsultez `NyxMapper` pour les cibles potentielles.\nUn nouveau fichier de hashes compromis a été loggué dans `/data/compromised_hashes.log`. L'application `PasswordCracker.app` pourrait être utile.\n\nBonne chasse.", read: false
                    });
                    if (!fileSystem['/tools/']) {
                        fileSystem['/tools/'] = { type: 'directory', children: ['PortProbe.tool', 'BasicExploit.sh', 'DataLeech.payload', 'run_evasion_protocol.sh', 'LogReaper.sh'], owner: 'nyx_user', permissions: 'rwxr-x---', protected: 1 };
                        if (fileSystem['/'] && !fileSystem['/'].children.includes('tools/')) fileSystem['/'].children.push('tools/');
                    } else { 
                         if (!fileSystem['/tools/'].children.includes('BasicExploit.sh')) fileSystem['/tools/'].children.push('BasicExploit.sh');
                         if (!fileSystem['/tools/'].children.includes('DataLeech.payload')) fileSystem['/tools/'].children.push('DataLeech.payload');
                         if (!fileSystem['/tools/'].children.includes('run_evasion_protocol.sh')) fileSystem['/tools/'].children.push('run_evasion_protocol.sh');
                         if (!fileSystem['/tools/'].children.includes('LogReaper.sh')) fileSystem['/tools/'].children.push('LogReaper.sh');
                    }
                     if (!fileSystem['/data/']) { 
                        fileSystem['/data/'] = { type: 'directory', children: ['compromised_hashes.log', 'oracle_core_schematics.dat'], owner: 'root', permissions: 'rwxr-x---', protected: 1 };
                         if (fileSystem['/'] && !fileSystem['/'].children.includes('data/')) fileSystem['/'].children.push('data/');
                    } else {
                        if (!fileSystem['/data/'].children.includes('compromised_hashes.log')) fileSystem['/data/'].children.push('compromised_hashes.log');
                        if (!fileSystem['/data/'].children.includes('oracle_core_schematics.dat')) fileSystem['/data/'].children.push('oracle_core_schematics.dat');
                    }
                     if (!fileSystem['/sys/modules/StealthModule.sys_CORRUPTED'] && !getNode('/sys/modules/StealthModule.sys_ACTIVE')) { 
                        if (!fileSystem['/sys/']) fileSystem['/sys/'] = { type: 'directory', children: ['modules/'], owner: 'root', permissions: 'rwxr-xr-x'};
                        if (!fileSystem['/sys/modules/']) fileSystem['/sys/modules/'] = { type: 'directory', children: [], owner: 'root', permissions: 'rwxr-xr-x'};
                        fileSystem['/sys/modules/StealthModule.sys_CORRUPTED'] = { type: 'file', content: ["MODULE STEALTH ENDOMMAGÉ", "Réactivation requiert séquence de diagnostic avancée.", "INDICE: Écho Delta"], owner: 'root', permissions: 'r--r--r--', protected: 2};
                        if(fileSystem['/sys/modules/'] && !fileSystem['/sys/modules/'].children.includes('StealthModule.sys_CORRUPTED')) {
                            fileSystem['/sys/modules/'].children.push('StealthModule.sys_CORRUPTED');
                        }
                     }


                } else { errorSound(); appendToTerminal("Échec authentification.", "error"); 
                    failedLoginAttempts++;
                    let traceIncrease = 5 * failedLoginAttempts;
                    if(isStealthModeActive) traceIncrease = Math.floor(traceIncrease / 2);
                    traceLevel = Math.min(100, traceLevel + traceIncrease); 
                    updateHeaderFooter();
                    if (failedLoginAttempts >= 3) {
                        triggerSystemAlert("Multiples tentatives de connexion échouées. Activité suspecte enregistrée.", "critical", "ALERTE DE SÉCURITÉ");
                    }
                }
            }
            
            // --- Logique des nouvelles applications ---
            function openEchoPlayer(filePath) {
                let nodeToPlay;
                if (filePath) {
                    const resolvedPath = resolvePath(filePath, currentDirectory);
                    nodeToPlay = getNode(resolvedPath);
                }

                if (nodeToPlay && nodeToPlay.type === 'echo_file') {
                    currentEcho = nodeToPlay; 
                    const echoFileName = filePath.split('/').pop(); 
                    windowManager.createWindow(`echo-player-${echoFileName}`, `Echo Player - ${echoFileName}`, (contentDiv) => {
                        const videoId = `echo-video-${Date.now()}`; 
                        const buttonId = `open-decryptor-btn-${Date.now()}`; 
                        contentDiv.innerHTML = `
                            <video id="${videoId}" class="echo-player-video" controls autoplay>
                                <source src="${nodeToPlay.videoUrl}" type="video/mp4">
                                Votre navigateur ne supporte pas la balise vidéo ou le format de la vidéo est incorrect.
                            </video>
                            <div class="echo-player-controls">
                                <p class="info text-sm mb-2">Indice/Question: ${nodeToPlay.enigma || "Analysez attentivement cet Écho."}</p>
                                <button id="${buttonId}" class="echo-player-controls button">Ouvrir Cognito Decryptor</button>
                            </div>`;
                        const videoElement = contentDiv.querySelector(`#${videoId}`);
                        videoElement.onerror = () => {
                            contentDiv.querySelector('.echo-player-controls').insertAdjacentHTML('afterbegin', '<p class="error">Erreur: Impossible de charger la vidéo. Vérifiez l\'URL.</p>');
                        };
                        contentDiv.querySelector(`#${buttonId}`).onclick = () => openCognitoDecryptor(nodeToPlay, echoFileName);
                    }, { width: '680px', height: 'auto' });
                } else if (filePath) {
                    appendToTerminal(`Erreur: '${filePath}' n'est pas un fichier Écho valide. Utilisez 'open /chemin/vers/fichier.echo'`, "error");
                } else {
                     appendToTerminal("Usage: open <chemin_vers_fichier.echo>", "info");
                }
            }
            function openCognitoDecryptor(echoData = null, echoName = "Inconnu") {
                const targetEcho = echoData || currentEcho; 

                windowManager.createWindow('cognito-decryptor', `Cognito Decryptor`, (contentDiv) => {
                    const inputId = `decryptor-input-${Date.now()}`;
                    const resultId = `decryptor-result-${Date.now()}`;
                    const buttonId = `decryptor-submit-btn-${Date.now()}`;

                    contentDiv.innerHTML = `
                        <p class="info text-sm mb-1">${targetEcho ? `Décryptage pour Écho: ${echoName}` : "Aucun Écho actif."}</p>
                        <p class="text-xs mb-3">${targetEcho ? (targetEcho.enigma || "Entrez la solution de l'Écho.") : "Veuillez sélectionner un Écho avant d'utiliser le décrypteur."}</p>
                        <input type="text" id="${inputId}" class="cognito-decryptor-input" placeholder="Solution...">
                        <button id="${buttonId}" class="cognito-decryptor-button">SOUMETTRE ANALYSE</button>
                        <div id="${resultId}" class="mt-3 text-sm"></div>
                    `;
                    
                    contentDiv.querySelector(`#${buttonId}`).onclick = () => {
                        const solutionInput = contentDiv.querySelector(`#${inputId}`).value;
                        const resultDiv = contentDiv.querySelector(`#${resultId}`);
                        if (targetEcho) {
                            if (solutionInput.trim().toUpperCase() === targetEcho.solution.toUpperCase()) {
                                resultDiv.innerHTML = '<p class="success">SOLUTION CORRECTE. Nouvelles données potentiellement débloquées.</p>';
                                successSound();
                                appendToTerminal(`[Cognito] Solution pour ${echoName} acceptée.`, "success");
                                
                                if (targetEcho.unlocksNode && networkNodes[targetEcho.unlocksNode]) {
                                    networkNodes[targetEcho.unlocksNode].locked = false;
                                    networkNodes[targetEcho.unlocksNode].status = 'Online'; 
                                    appendToTerminal(`[NyxMapper] Accès au nœud '${networkNodes[targetEcho.unlocksNode].label}' déverrouillé.`, "success");
                                    const mapperCanvas = document.getElementById('nyx-mapper-canvas');
                                    if(mapperCanvas) drawNyxMapper(mapperCanvas);
                                }
                                if (targetEcho.nextMessageId) {
                                    const messagesToAdd = {
                                        "msg_alpha_solved": { id: `msg_alpha_solved_${Date.now()}`, sender: 'Nyx_Admin', subject: 'Progression : Archive Alpha', timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), body: "Bien joué, Opérateur.\nL'analyse de l'Écho Alpha a permis de localiser l'archive de données 'Data Archive α'.\nElle est maintenant accessible sur NyxMapper.\nUtilisez PortProbe.tool pour examiner ses vulnérabilités.", read: false },
                                        "msg_beta_solved": {id: `msg_beta_solved_${Date.now()}`, sender: "Unknown_Contact", subject: "Le Relais Zeta...", timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), body: "Le Relais Zeta est de nouveau en ligne grâce à vous... mais pour combien de temps ?\nDes signaux étranges en émanent. Soyez prudent.", read: false},
                                        "msg_gamma_solved": {id: `msg_gamma_solved_${Date.now()}`, sender: "Nyx_OracleAI_Fragment", subject: "Fragment Gamma Analysé", timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), body: "Symbole OMEGA identifié.\nCeci est une pièce maîtresse du puzzle de l'Oracle.\nDe nouvelles directives suivront. Restez vigilant.", read: false},
                                        "msg_delta_solved": {id: `msg_delta_solved_${Date.now()}`, sender: "Nyx_TechSupport", subject: "Module Stealth Réparé", timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), body: "Excellent travail, Opérateur.\nLa séquence de diagnostic de l'Écho Delta a permis de réactiver le StealthModule.sys.\nUtilisez la commande 'stealth_mode on' pour réduire votre niveau de trace lors d'opérations sensibles.", read: false}
                                    };
                                    if(messagesToAdd[targetEcho.nextMessageId]) {
                                        addNewNyxMessage(messagesToAdd[targetEcho.nextMessageId]);
                                    }
                                }
                                if (targetEcho.unlocksFeature === "stealth_module") {
                                    const stealthModuleActive = getNode('/sys/modules/StealthModule.sys_ACTIVE');
                                    if (!stealthModuleActive) { 
                                        fileSystem['/sys/modules/StealthModule.sys_ACTIVE'] = {type: 'file', content: ["// Module Stealth Actif - Version 1.2 //", "Réduit la signature des opérations."], owner: 'root', permissions: 'r-xr-xr-x', protected: 1};
                                        if(fileSystem['/sys/modules/'] && !fileSystem['/sys/modules/'].children.includes('StealthModule.sys_ACTIVE')) {
                                            fileSystem['/sys/modules/'].children.push('StealthModule.sys_ACTIVE');
                                        }
                                        const corruptedIndex = fileSystem['/sys/modules/'].children.indexOf('StealthModule.sys_CORRUPTED');
                                        if (corruptedIndex > -1) fileSystem['/sys/modules/'].children.splice(corruptedIndex, 1);
                                        delete fileSystem['/sys/modules/StealthModule.sys_CORRUPTED'];
                                        appendToTerminal("[SYSTEM] Module Stealth réactivé. Commande 'stealth_mode' disponible.", "success");
                                    }
                                }
                            } else {
                                resultDiv.innerHTML = '<p class="error">SOLUTION INCORRECTE. Tentative enregistrée.</p>';
                                errorSound();
                            }
                        } else {
                            resultDiv.innerHTML = '<p class="warning">Veuillez sélectionner un Écho avant d\'utiliser le décrypteur.</p>';
                        }
                    };
                }, { width: '420px', height: '280px' });
            }
            
            function openPasswordCracker() {
                windowManager.createWindow('password-cracker', 'Password Cracker v1.0', (contentDiv) => {
                    const inputId = `cracker-input-${Date.now()}`;
                    const resultId = `cracker-result-${Date.now()}`;
                    const buttonId = `cracker-submit-btn-${Date.now()}`;
                    const progressBarContainerId = `cracker-progress-container-${Date.now()}`;
                    const progressBarId = `cracker-progress-${Date.now()}`;

                    contentDiv.innerHTML = `
                        <p class="info text-sm mb-2">Entrez le hash à cracker (depuis /data/compromised_hashes.log) :</p>
                        <input type="text" id="${inputId}" class="password-cracker-input" placeholder="ex: 6a8f5c2b9d0e1f3a7c4b8e0d2f1a3c5b">
                        <button id="${buttonId}" class="password-cracker-button">LANCER CRACK</button>
                        <div id="${progressBarContainerId}" class="cracker-progress-bar-container">
                            <div id="${progressBarId}" class="cracker-progress-bar"></div>
                        </div>
                        <div id="${resultId}" class="cracker-result mt-2"></div>
                    `;

                    const inputEl = contentDiv.querySelector(`#${inputId}`);
                    const resultEl = contentDiv.querySelector(`#${resultId}`);
                    const buttonEl = contentDiv.querySelector(`#${buttonId}`);
                    const progressContainerEl = contentDiv.querySelector(`#${progressBarContainerId}`);
                    const progressBarEl = contentDiv.querySelector(`#${progressBarId}`);

                    buttonEl.onclick = () => {
                        const hashToCrack = inputEl.value.trim();
                        if (!hashToCrack) {
                            resultEl.innerHTML = '<p class="warning">Veuillez entrer un hash.</p>';
                            return;
                        }
                        resultEl.innerHTML = '<p class="info"><span class="spinner"></span> Crack en cours...</p>';
                        progressContainerEl.style.display = 'block';
                        progressBarEl.style.width = '0%';
                        
                        let currentProgress = 0;
                        const progressInterval = setInterval(() => {
                            currentProgress += Math.floor(Math.random() * 10) + 5;
                            if (currentProgress > 100) currentProgress = 100;
                            progressBarEl.style.width = `${currentProgress}%`;
                            if (currentProgress >= 100) {
                                clearInterval(progressInterval);
                                const hashesNode = getNode('/data/compromised_hashes.log');
                                let foundPassword = null;
                                if (hashesNode && hashesNode.type === 'file') {
                                    const lines = hashesNode.content;
                                    for (let i = 0; i < lines.length; i++) {
                                        if (lines[i].startsWith("HASH:") && lines[i].includes(hashToCrack)) {
                                            if (lines[i+1] && lines[i+1].startsWith("PLAINTEXT_SOLUTION:")) {
                                                foundPassword = lines[i+1].split(":")[1].trim();
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (foundPassword) {
                                    resultEl.innerHTML = `<p class="success">MOT DE PASSE TROUVÉ : <span class="font-bold text-cyan-bright">${foundPassword}</span></p>`;
                                    successSound();
                                    appendToTerminal(`[PasswordCracker] Hash ${hashToCrack} résolu : ${foundPassword}`, "success");
                                } else {
                                    resultEl.innerHTML = '<p class="error">ÉCHEC DU CRACK. Hash inconnu ou trop complexe.</p>';
                                    errorSound();
                                }
                                progressContainerEl.style.display = 'none';
                            }
                        }, 200);
                    };
                }, {width: '450px', height: 'auto'});
            }

            function openNyxDecryptor() {
                windowManager.createWindow('nyx-decryptor', 'NyxDecryptor v1.0', (contentDiv) => {
                    const fileInputId = `decryptor-file-input-${Date.now()}`;
                    const keyInputId = `decryptor-key-input-${Date.now()}`;
                    const resultId = `decryptor-output-${Date.now()}`;
                    const buttonId = `decryptor-submit-btn-${Date.now()}`;

                    contentDiv.innerHTML = `
                        <p class="info text-sm mb-2">Chemin du fichier chiffré (.nyxenc) :</p>
                        <input type="text" id="${fileInputId}" class="nyx-decryptor-input" placeholder="/data/encrypted_oracle_data.nyxenc">
                        <p class="info text-sm mb-2 mt-3">Clé de déchiffrement :</p>
                        <input type="password" id="${keyInputId}" class="nyx-decryptor-key-input" placeholder="Clé...">
                        <button id="${buttonId}" class="nyx-decryptor-button">DÉCRYPTER</button>
                        <div id="${resultId}" class="decryption-output" style="display:none;"></div>
                    `;

                    const fileInputEl = contentDiv.querySelector(`#${fileInputId}`);
                    const keyInputEl = contentDiv.querySelector(`#${keyInputId}`);
                    const resultEl = contentDiv.querySelector(`#${resultId}`);
                    const buttonEl = contentDiv.querySelector(`#${buttonId}`);

                    buttonEl.onclick = () => {
                        const filePath = resolvePath(fileInputEl.value.trim(), currentDirectory);
                        const decryptionKey = keyInputEl.value.trim();
                        const fileNode = getNode(filePath);

                        resultEl.style.display = 'none';
                        resultEl.innerHTML = '';

                        if (!fileNode) {
                            resultEl.innerHTML = '<p class="error">Fichier non trouvé.</p>';
                            resultEl.style.display = 'block'; errorSound(); return;
                        }
                        if (fileNode.type !== 'file' || !fileNode.encrypted || !filePath.endsWith('.nyxenc')) {
                            resultEl.innerHTML = '<p class="error">Ce fichier n\'est pas un fichier chiffré valide (.nyxenc).</p>';
                            resultEl.style.display = 'block'; errorSound(); return;
                        }
                        if (!decryptionKey) {
                            resultEl.innerHTML = '<p class="warning">Veuillez entrer une clé de déchiffrement.</p>';
                            resultEl.style.display = 'block'; return;
                        }

                        appendToTerminal(`[NyxDecryptor] Tentative de déchiffrement de ${filePath}...`, "info");
                        setTimeout(() => { 
                            if (decryptionKey.toUpperCase() === fileNode.decryptionKey.toUpperCase()) {
                                resultEl.innerHTML = `<p class="success">DÉCHIFFREMENT RÉUSSI :</p><pre>${fileNode.content.join('\n')}</pre>`;
                                successSound();
                                appendToTerminal(`[NyxDecryptor] Fichier ${filePath} déchiffré avec succès.`, "success");
                                if (filePath.includes('encrypted_oracle_data.nyxenc')) {
                                     addNewNyxMessage({
                                        id: `msg_decrypt_oracle_${Date.now()}`, sender: 'Nyx_CipherBreaker', subject: 'Données Oracle Déchiffrées !', timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), 
                                        body: `Excellent travail, Opérateur.\nLes données de l'Oracle dans /data/encrypted_oracle_data.nyxenc ont été déchiffrées.\nLe contenu semble pointer vers le 'Protocole Somnus' et une clé 'OMEGA'.\nCeci pourrait être lié aux schémas du noyau que vous avez extraits.\nUne analyse plus approfondie est nécessaire. L'Écho Gamma semble pertinent.`, read: false
                                    });
                                }

                            } else {
                                resultEl.innerHTML = '<p class="error">ÉCHEC DU DÉCHIFFREMENT. Clé incorrecte.</p>';
                                errorSound();
                                traceLevel = Math.min(100, traceLevel + (isStealthModeActive ? 5 : 10)); updateHeaderFooter();
                            }
                            resultEl.style.display = 'block';
                        }, 1500 + Math.random() * 1000);
                    };

                }, {width: '500px', height: 'auto'});
            }

            function openNetViz(targetNodeId = null) {
                const winId = `netviz-window-${targetNodeId || 'generic'}-${Date.now()}`; 
                let targetNode = targetNodeId ? networkNodes[targetNodeId] : null;
            
                windowManager.createWindow(winId, `NetViz v0.1 ${targetNode ? '- Moniteur: ' + targetNode.label : ''}`, (contentDiv) => {
                    contentDiv.innerHTML = `<div class="netviz-output">INITIALISATION DU FLUX DE DONNÉES...</div>`;
                    const outputDiv = contentDiv.querySelector('.netviz-output');
                    let packetCount = 0;
                    
                    if (netVizInterval) clearInterval(netVizInterval); 

                    function generateFakePacket() {
                        packetCount++;
                        const protocols = ["TCP", "UDP", "ICMP", "NYX_ECHO"];
                        const srcIpBase = targetNode ? targetNode.ip.substring(0, targetNode.ip.lastIndexOf('.')+1) : `10.0.${Math.floor(Math.random()*255)}.`;
                        const srcIp = srcIpBase + Math.floor(Math.random()*255);
                        const dstIp = `203.0.113.${Math.floor(Math.random()*255)}`;
                        const protocol = protocols[Math.floor(Math.random() * protocols.length)];
                        const payloadFragments = ["DATA_CHUNK", "HEARTBEAT", "ENCRYPTED_STREAM", "AUTH_REQ", "ECHO_FRAG", "NULL_PACKET", "CORRUPTED_SEQ"];
                        let payload = payloadFragments[Math.floor(Math.random() * payloadFragments.length)];
                        
                        /* MBAPPE: NETVIZ_HINT_HIDDEN_RELAY_ZETA */
                        if (targetNodeKey === 'hidden_relay_zeta' && networkNodes['hidden_relay_zeta'] && networkNodes['hidden_relay_zeta'].status === 'Online' && packetCount % 25 === 0) { 
                            payload = "TRANSMISSION CRYPTÉE DETECTÉE - FRAGMENT EPSILON - ACCÈS : Protocole Somnus";
                        } 
                        /* MBAPPE: NETVIZ_HINT_CORP_FIREWALL */
                        else if (targetNodeKey === 'corp_firewall' && packetCount % 30 === 0) {
                            payload = "ALERTE: Tentative d'intrusion bloquée - Source : 10.0.1.1 (NYX_MAINFRAME?)";
                        }


                        const packetLine = document.createElement('div');
                        packetLine.className = 'netviz-packet';
                        packetLine.innerHTML = 
                            `[${new Date().toLocaleTimeString()}] <span class="src-ip">${srcIp}</span> -> <span class="dst-ip">${dstIp}</span> ` +
                            `PROTO:<span class="protocol">${protocol}</span> LEN:${Math.floor(Math.random()*1500)} <span class="payload-fragment">// ${payload}</span>`;
                        outputDiv.appendChild(packetLine);
                        if(outputDiv.children.length > 100) { 
                            outputDiv.removeChild(outputDiv.firstChild);
                        }
                        outputDiv.scrollTop = outputDiv.scrollHeight;
                    }
            
                    if (targetNode && node.status && node.status.toLowerCase().includes("compromis")) {
                        outputDiv.innerHTML = `<p class="success">CONNEXION AU FLUX DE ${targetNode.label} ÉTABLIE...</p>`;
                        netVizInterval = setInterval(generateFakePacket, 700 + Math.random() * 500);
                    } else if (targetNode) {
                         outputDiv.innerHTML = `<p class="error">ERREUR: Accès au flux de ${targetNode.label} refusé. Le nœud n'est pas compromis.</p>`;
                    } else {
                        outputDiv.innerHTML = `<p class="warning">Aucun nœud cible spécifié. Affichage du trafic général du sous-réseau (simulé)...</p>`;
                        netVizInterval = setInterval(generateFakePacket, 1000 + Math.random() * 800);
                    }
                }, { width: '600px', height: '400px' });
            }


            // --- NyxComms Logic ---
            const nyxMessages = [
                { id: 'msg001', sender: 'Nyx_Admin', subject: 'Bienvenue, Opérateur', timestamp: '2077.10.26_02:33', body: "Vos identifiants ont été validés.\nVotre première tâche : localiser et analyser l'Écho Alpha.\nIl se trouve dans /echo_fragments/fragment_alpha.echo\nUtilisez la commande 'open' pour le visionner.\n\nLe Voile observe.", read: false },
                { id: 'msg002', sender: 'Unknown_Contact', subject: 'AVERTISSEMENT URGENT', timestamp: '2077.10.25_18:05', body: "Ils savent que vous cherchez.\nL'Oracle n'est pas mort, il est fragmenté.\nChaque Écho est une clé, mais aussi un piège.\nMéfiez-vous des ombres que vous ne projetez pas.\n\nIndice pour le pare-feu CorpX : cherchez les ports non standards souvent utilisés pour le débogage HTTP.\nIl est visible sur NyxMapper, mais son accès direct est... compliqué.\n\n- Un Ami (ou pas)", read: false },
                { id: 'msg003', sender: 'Nyx_TechSupport', subject: 'Rapport Système : Module IA', timestamp: '2077.10.26_09:15', body: "Le module d'analyse NyxCore_AI est actuellement hors-ligne pour maintenance.\nLes analyses d'Échos devront être effectuées manuellement via CognitoDecryptor.\nNous travaillons à sa réintégration.\n\n- Support Technique NyxNet", read: true }
            ];
            let hasUnreadMessages = nyxMessages.some(msg => !msg.read);

            function updateCommsIndicator() {
                if (commsIndicatorEl) {
                    hasUnreadMessages = nyxMessages.some(msg => !msg.read);
                    if (hasUnreadMessages) {
                        commsIndicatorEl.classList.add('new-message');
                    } else {
                        commsIndicatorEl.classList.remove('new-message');
                    }
                }
            }
            
            function addNewNyxMessage(newMessage) {
                nyxMessages.unshift(newMessage); 
                updateCommsIndicator();
                const commsWindowContent = windowManager.getWindowContent('window-nyx-comms');
                if (commsWindowContent) {
                    const listPanel = commsWindowContent.querySelector('#message-list-panel');
                    const viewPanel = commsWindowContent.querySelector('#message-view-panel');
                    if (listPanel && viewPanel) { 
                         renderMessageListInComms(listPanel, viewPanel); 
                    }
                }
                successSound(); 
            }
            
            function renderMessageListInComms(listPanel, viewPanel) { 
                listPanel.innerHTML = ''; 
                nyxMessages.sort((a,b) => (a.read === b.read) ? 0 : a.read ? 1 : -1); 
                nyxMessages.forEach(msg => {
                    const msgItem = document.createElement('div');
                    msgItem.className = 'message-item';
                    msgItem.classList.toggle('unread', !msg.read);
                    msgItem.classList.toggle('read', msg.read);
                    
                    msgItem.innerHTML = `
                        <span class="message-sender">${msg.sender}</span>
                        <span class="message-subject">${msg.subject}</span>
                        <span class="message-timestamp">${msg.timestamp}</span>
                    `;
                    
                    msgItem.onclick = () => {
                        document.querySelectorAll('#message-list-panel .message-item.selected').forEach(el => el.classList.remove('selected'));
                        msgItem.classList.add('selected');
                        msgItem.classList.remove('unread');
                        msgItem.classList.add('read');
                        msg.read = true;
                        updateCommsIndicator();

                        viewPanel.innerHTML = `
                            <h4>De: ${msg.sender}</h4>
                            <p style="font-size:0.8em; opacity:0.7; margin-bottom:10px;">Sujet: ${msg.subject}<br>Date: ${msg.timestamp}</p>
                            <div class="message-body">${msg.body.replace(/\n/g, '<br>')}</div>
                        `;
                    };
                    listPanel.appendChild(msgItem);
                });
            }


            function openNyxComms() {
                windowManager.createWindow('nyx-comms', 'NyxComms v0.3', (contentDiv) => {
                    contentDiv.innerHTML = `
                        <div class="nyx-comms-container">
                            <div id="message-list-panel" class="message-list-panel"></div>
                            <div id="message-view-panel" class="message-view-panel">
                                <p class="info">Sélectionnez un message pour le lire.</p>
                            </div>
                        </div>`;
                    const listPanel = contentDiv.querySelector('#message-list-panel');
                    const viewPanel = contentDiv.querySelector('#message-view-panel');
                    renderMessageListInComms(listPanel, viewPanel); 
                    updateCommsIndicator(); 
                }, {width: '700px', height: '500px'});
            }


            async function handleCommand(cmd) {
                if (systemLocked && cmd.trim() !== './tools/run_evasion_protocol.sh') {
                    appendToTerminal("SYSTEM LOCKDOWN: Commandes restreintes. Exécutez ./tools/run_evasion_protocol.sh", "error");
                    errorSound();
                    return;
                }

                const [command, ...args] = cmd.trim().split(' ');
                if (terminalOutput && promptElement) appendToTerminal(`${promptElement.textContent}${cmd}`);
                keyClickSound();

                if (command.startsWith('./')) {
                    const scriptPath = resolvePath(command.substring(2), currentDirectory);
                    const scriptNode = getNode(scriptPath);
                    if (scriptNode && scriptNode.type === 'executable') {
                        if (scriptNode.action) { 
                           await scriptNode.action(args); 
                        } else {
                            appendToTerminal(`Erreur: Action non définie pour le script '${command.substring(2)}'.`, "error");
                        }
                    } else {
                        appendToTerminal(`Script non trouvé ou non exécutable: ${command.substring(2)}`, "error");
                    }
                    return;
                }
                switch(command.toLowerCase()){
                    case 'help': appendToTerminal("Commandes: ls, cd, cat, ./login.sh, apps, open <fichier.echo>, clear, help, music on/off, stealth_mode [on|off]", "info"); break;
                    case 'ls': 
                        const nodeLs = getNode(currentDirectory);
                        if (nodeLs && nodeLs.type === 'directory') {
                            appendToTerminal(`Contenu de ${currentDirectory}:`, 'info');
                            nodeLs.children.forEach(c => appendToTerminal(c));
                        } else appendToTerminal("Erreur: Chemin invalide", "error");
                        break;
                    case 'cd': 
                         if (!args[0]) { appendToTerminal("Usage: cd <répertoire>", "info"); break;}
                         const newPath = resolvePath(args[0], currentDirectory);
                         const targetNodeCd = getNode(newPath);
                         if (targetNodeCd && targetNodeCd.type === 'directory') { currentDirectory = newPath; updatePrompt();}
                         else { appendToTerminal(`Répertoire non trouvé: ${args[0]}`, "error");}
                        break;
                    case 'cat': 
                        if (!args[0]) { appendToTerminal("Usage: cat <fichier>", "info"); break;}
                        const filePathCat = resolvePath(args[0], currentDirectory);
                        const fileNodeCat = getNode(filePathCat);
                        if (fileNodeCat && fileNodeCat.type === 'file') {
                            if (fileNodeCat.protected > accessLevel) {
                                appendToTerminal("Accès refusé. Niveau insuffisant.", "error"); errorSound(); break;
                            }
                             if (fileNodeCat.encrypted) {
                                appendToTerminal(`Le fichier '${args[0]}' est chiffré. Utilisez NyxDecryptor.app.`, "warning");
                                errorSound();
                                break; 
                            } else {
                                appendToTerminal(fileNodeCat.content.join('\n'));
                            }
                        } else { appendToTerminal(`Fichier non trouvé: ${args[0]}`, "error");}
                        break;
                    case 'apps': 
                        appendToTerminal("Applications disponibles dans /apps/:", "info");
                        const appsNode = getNode('/apps/');
                        if (appsNode && appsNode.children) {
                            appsNode.children.forEach(app => appendToTerminal(`  ${app} (exécuter avec ./apps/${app})`));
                        }
                        break;
                    case 'open': 
                        if (args[0]) openEchoPlayer(args[0]);
                        else appendToTerminal("Usage: open <chemin_vers_fichier.echo>", "info");
                        break;
                    case 'clear': if(terminalOutput) terminalOutput.innerHTML = ""; break;
                    case 'music':
                        if (args[0] === 'on') startBackgroundMusic();
                        else if (args[0] === 'off') stopBackgroundMusic();
                        else appendToTerminal("Usage: music [on|off]", "info");
                        break;
                    case 'stealth_mode':
                        const stealthModuleActive = getNode('/sys/modules/StealthModule.sys_ACTIVE');
                        if (!stealthModuleActive) {
                            appendToTerminal("Erreur: Module Stealth non actif ou introuvable. Réparez-le via l'Écho Delta.", "error");
                            traceLevel = Math.min(100, traceLevel + 2); updateHeaderFooter();
                            break;
                        }
                        if (args[0] === 'on') {
                            isStealthModeActive = true;
                            appendToTerminal("Mode Stealth <span class='text-purple-bright'>ACTIVÉ</span>. Augmentation du niveau de trace réduite.", "success", true);
                        } else if (args[0] === 'off') {
                            isStealthModeActive = false;
                            appendToTerminal("Mode Stealth <span class='text-orange-warning'>DÉSACTIVÉ</span>.", "info", true);
                        } else {
                            appendToTerminal("Usage: stealth_mode [on|off]", "info");
                        }
                        updateHeaderFooter(); 
                        break;
                    default: appendToTerminal(`Commande inconnue: '${command}'.`, "error"); errorSound();
                }
            }

            // --- Séquence de Boot ---
            const bootMessages = [
                { text: "INIT NYX_KERNEL_V3.0...", delay: 200, progress: 10 },
                { text: "MEMORY CHECK...........OK", delay: 300, progress: 25 },
                { text: "LOADING CORE MODULES...", delay: 500, progress: 50 },
                { text: "ORACLE ECHO HANDLER....ONLINE", delay: 400, progress: 65, type: 'success'},
                { text: "ENCRYPTION LAYER.......ACTIVE", delay: 300, progress: 75 },
                { text: "NYXOS 'ORACLE ECHOES' ONLINE", delay: 200, progress: 100, type: 'success' }
            ];
            async function runBootSequence(messages) {
                for (let i = 0; i < messages.length; i++) {
                    const msg = messages[i];
                    if (bootTextEl) {
                        const p = document.createElement('p');
                        if (msg.type) p.className = msg.type;
                        p.textContent = msg.text;
                        bootTextEl.appendChild(p);
                    }
                    if (bootProgressBarEl) bootProgressBarEl.style.width = `${msg.progress}%`;
                    await new Promise(resolve => setTimeout(resolve, msg.delay));
                }
                setTimeout(() => {
                    if (bootScreenEl) bootScreenEl.style.display = 'none';
                    if (desktopEl) desktopEl.style.display = 'flex'; 
                    windowManager.createWindow('nyx-terminal', 'NyxTerm v3.0', (contentDiv) => {
                        contentDiv.innerHTML = `<div id="terminal-output"></div><div class="prompt-line"><span id="prompt"></span><input type="text" id="terminal-input" class="terminal-input" spellcheck="false" autofocus/></div>`;
                        terminalOutput = contentDiv.querySelector('#terminal-output');
                        terminalInput = contentDiv.querySelector('#terminal-input');
                        promptElement = contentDiv.querySelector('#prompt');
                        appendToTerminal("Bienvenue sur NyxOS v3.0. Tapez 'help' pour les commandes.", "info");
                        updatePrompt();
                        terminalInput.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                const command = terminalInput.value;
                                if (command.trim() !== "") commandHistory.unshift(command);
                                historyIndex = -1;
                                handleCommand(command);
                                terminalInput.value = '';
                            } 
                        });
                    }, { width: '70%', height: '70%' });
                    updateCommsIndicator(); 
                }, 300);
            }
            runBootSequence(bootMessages);

            // --- Horloge et Status ---
            function updateHeaderFooter() {
                if (nyxClockEl) nyxClockEl.textContent = new Date().toLocaleTimeString('fr-FR');
                if (userStatusEl && currentUser) userStatusEl.textContent = `USER: ${currentUser} (LVL: ${accessLevel})`;
                if (traceLevelStatusEl) {
                    traceLevelStatusEl.textContent = `TRACE: ${traceLevel}%`;
                    if (isStealthModeActive) {
                        traceLevelStatusEl.classList.add('stealth');
                        traceLevelStatusEl.title = "Mode Stealth Actif";
                    } else {
                        traceLevelStatusEl.classList.remove('stealth');
                        traceLevelStatusEl.title = "";
                    }
                }
                if (traceLevel >= 100 && !systemLocked) {
                     systemLocked = true;
                     triggerSystemAlert("NIVEAU DE TRACE CRITIQUE - VERROUILLAGE SYSTÈME EN COURS ! Exécutez ./tools/run_evasion_protocol.sh IMMÉDIATEMENT.", "critical", "ALERTE MAXIMALE - LOCKDOWN");
                     windowManager.closeAllWindows(); 
                     if(terminalOutput) appendToTerminal("\n\n>>> SYSTEM LOCKDOWN INITIATED <<<\n>>> COMMANDS RESTRICTED <<<\n>>> EXECUTE EVASION PROTOCOL: ./tools/run_evasion_protocol.sh <<<\n", "error");
                } else if (traceLevel < 100 && systemLocked) {
                    // Le déverrouillage est géré par run_evasion_protocol.sh
                } else if (traceLevel >= 75 && traceLevel < 100 && systemAlertOverlayEl.style.display === 'none') { 
                    triggerSystemAlert("NIVEAU DE TRACE ÉLEVÉ - PRUDENCE REQUISE !", "warning", "ALERTE SÉCURITÉ");
                }
            }
            setInterval(updateHeaderFooter, 1000);
            updateHeaderFooter(); 
            
            document.body.addEventListener('click', async () => { if (Tone.context.state !== 'running') await Tone.start(); }, { once: true });
        };
    </script>
</body>
</html>
