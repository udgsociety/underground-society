<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NyxOS v1.0 - Digital Veil</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #00FF41; 
            --secondary-color: #0DFFFF; 
            --tertiary-color: #9D00FF; 
            --error-color: #FF0033; 
            --warning-color: #FFD700; 
            --background-color: #010302; 
            --window-bg-color: rgba(5, 15, 10, 0.8); 
            --window-border-color: rgba(0, 255, 65, 0.3);
            --window-header-bg: rgba(0, 40, 20, 0.9);
            --font-main: 'Roboto Mono', monospace;
            --font-display: 'Share Tech Mono', monospace;
            --font-pixel: 'VT323', monospace; 
            --primary-color-rgb: 0, 255, 65;
            --secondary-color-rgb: 13, 255, 255;
            --text-glow: 0 0 3px rgba(var(--primary-color-rgb), 0.7), 0 0 6px rgba(var(--primary-color-rgb), 0.5);
        }

        /* --- Animations Clés --- */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes subtleScanline { 0% { background-position: 0 0; } 100% { background-position: 0 3px; } }
        @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        @keyframes glitchLine { 0% { transform: translateY(0); } 50% { transform: translateY(2px); } 100% { transform: translateY(0); } }
        @keyframes pulseBorder { 0%, 100% { border-color: var(--window-border-color); box-shadow: 0 0 10px rgba(var(--primary-color-rgb), 0.2); } 50% { border-color: var(--primary-color); box-shadow: 0 0 25px rgba(var(--primary-color-rgb), 0.6); } }
        @keyframes blink { 0% { opacity: .2; } 20% { opacity: 1; } 100% { opacity: .2; } }

        /* --- Fond Digital Rain --- */
        #matrix-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--background-color);
            z-index: -1; /* Derrière tout */
        }

        /* --- Corps et Bureau --- */
        body {
            font-family: var(--font-main);
            background-color: transparent; /* Transparent pour voir le canvas */
            color: var(--primary-color);
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100vh;
            animation: fadeIn 1.5s ease-out;
        }

        #desktop {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
            padding: 10px;
            display: grid;
            grid-template-areas:
                "header header header"
                "left main right"
                "footer footer footer";
            grid-template-columns: 200px 1fr 200px;
            grid-template-rows: 40px 1fr 30px;
            gap: 10px;
        }
        
        /* --- Scanline Superposition --- */
        .scanline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient( to bottom, rgba(20,20,30,0) 50%, rgba(0,0,0,0.25) 51%, rgba(20,20,30,0) 52% );
            background-size: 100% 3px;
            animation: subtleScanline 0.15s linear infinite;
            opacity: 0.15;
            z-index: 9999;
        }

        /* --- Éléments Décoratifs / Widgets --- */
        .widget {
            background: rgba(10, 30, 20, 0.6);
            border: 1px solid rgba(var(--primary-color-rgb), 0.2);
            border-radius: 5px;
            padding: 10px;
            font-family: var(--font-display);
            font-size: 0.8em;
            color: var(--primary-color);
            backdrop-filter: blur(3px);
            overflow: hidden;
        }
        #widget-header { grid-area: header; text-align: center; font-size: 1.5em; text-shadow: var(--text-glow); display: flex; align-items: center; justify-content: center; border-bottom: 1px solid var(--primary-color);}
        #widget-left { grid-area: left; }
        #widget-right { grid-area: right; }
        #widget-footer { grid-area: footer; text-align: center; font-size: 0.9em; display: flex; align-items: center; justify-content: space-around; border-top: 1px solid var(--primary-color); }
        .widget h3 { font-family: var(--font-pixel); font-size: 1.3em; margin-bottom: 10px; color: var(--secondary-color); text-shadow: 0 0 3px var(--secondary-color); border-bottom: 1px dashed rgba(var(--secondary-color-rgb), 0.5);}
        .widget p { margin-bottom: 5px; opacity: 0.8; animation: flicker 7s infinite alternate; }
        #cpu-graph, #net-graph { width: 100%; height: 50px; background: #050a08; border: 1px solid #111; position: relative; overflow: hidden; margin-top: 10px; }
        .graph-bar { position: absolute; bottom: 0; width: 5px; background: var(--primary-color); animation: graph-anim 0.5s infinite linear; }
        @keyframes graph-anim { 0% { height: 10%; } 25% { height: 60%; } 50% { height: 30%; } 75% { height: 80%; } 100% { height: 10%; } }

        /* --- Fenêtres --- */
        .window {
            grid-area: main; /* La fenêtre principale va ici */
            position: absolute; /* Reste absolu pour le drag & drop */
            background-color: var(--window-bg-color);
            border: 1px solid var(--window-border-color);
            border-radius: 6px;
            box-shadow: 0 0 20px rgba(var(--primary-color-rgb), 0.3), inset 0 0 8px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            min-width: 400px;
            min-height: 300px;
            backdrop-filter: blur(6px) saturate(150%);
            resize: both; 
            overflow: hidden; 
            transition: box-shadow 0.3s ease, border-color 0.3s ease;
            animation: pulseBorder 5s infinite alternate; /* Animation de bordure */
        }
        .window.active-window {
             border-color: var(--primary-color);
             box-shadow: 0 0 35px rgba(var(--primary-color-rgb), 0.7), 0 0 60px rgba(var(--primary-color-rgb), 0.4);
             animation: none; /* Stopper l'animation pulse quand active */
        }
        .window-header {
            background-color: var(--window-header-bg);
            padding: 8px 15px; 
            cursor: move;
            border-bottom: 1px solid var(--primary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
        }
        .window-title {
            font-family: var(--font-display);
            font-size: 1.4em; 
            color: var(--primary-color);
            text-shadow: var(--text-glow);
        }
        .window-buttons span {
            display: inline-block;
            width: 12px; height: 12px;
            border-radius: 2px; /* Boutons carrés pour un look plus tech */
            margin-left: 6px;
            cursor: pointer;
            transition: transform 0.2s ease, filter 0.2s ease;
            border: 1px solid rgba(0,0,0,0.5);
        }
        .window-buttons span:hover { transform: scale(1.1); filter: brightness(1.5); }
        .window-buttons .close-btn { background-color: var(--error-color); box-shadow: 0 0 6px var(--error-color); }
        .window-buttons .minimize-btn { background-color: var(--warning-color); box-shadow: 0 0 6px var(--warning-color); }
        .window-buttons .maximize-btn { background-color: var(--secondary-color); box-shadow: 0 0 6px var(--secondary-color); }

        .window-content {
            flex-grow: 1;
            padding: 15px; 
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) rgba(0,0,0,0.3);
            line-height: 1.6; 
            font-size: 0.95em; /* Texte légèrement plus petit pour plus de contenu */
            /* Effet de texte scanline interne */
             background-image: linear-gradient(rgba(0,0,0,0.05) 50%, transparent 50%);
             background-size: 100% 2px;
        }
        .window-content::-webkit-scrollbar { width: 10px; }
        .window-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        .window-content::-webkit-scrollbar-thumb { background-color: var(--primary-color); border-radius: 0; border: 1px solid rgba(0,0,0,0.5); }
        .window-content::-webkit-scrollbar-thumb:hover { background-color: var(--secondary-color); }

        /* --- Terminal Spécifique --- */
        #terminal-output {
            white-space: pre-wrap;
            word-wrap: break-word; 
            overflow-wrap: break-word; /* Correction pour superposition */
            text-shadow: 0 0 1px rgba(var(--primary-color-rgb), 0.5);
            height: calc(100% - 40px); /* Hauteur moins la ligne de prompt */
            overflow-y: auto; /* Assurer le scroll vertical */
        }
        .prompt-line { display: flex; align-items: center; margin-top: 5px; height: 30px; }
        .prompt { 
            font-family: var(--font-display);
            margin-right: 10px; 
            font-size: 1.1em;
            text-shadow: var(--text-glow);
        }
        .terminal-input {
            background-color: transparent;
            border: none;
            color: var(--primary-color);
            flex-grow: 1;
            outline: none;
            caret-color: var(--tertiary-color);
            font-family: inherit; 
            font-size: 1.1em; 
            text-shadow: var(--text-glow);
        }
        .terminal-input::placeholder { color: rgba(var(--primary-color-rgb), 0.3); font-style: italic; }

        /* --- Couleurs de Texte --- */
        .error { color: var(--error-color); font-weight: bold; text-shadow: 0 0 5px var(--error-color); animation: flicker 0.5s infinite; }
        .info { color: var(--secondary-color); text-shadow: 0 0 3px var(--secondary-color); }
        .success { color: #66FF66; text-shadow: 0 0 5px #66FF66; } 
        .warning { color: var(--warning-color); font-weight: bold; text-shadow: 0 0 5px var(--warning-color); }
        .filename { color: #A0FFA0; } 
        .dirname { color: #A0D8FF; } 

        /* --- Écran de Boot --- */
        #boot-screen {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: #000; color: var(--primary-color); z-index: 10000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-family: var(--font-pixel); font-size: 1.6em; padding: 20px; text-align: left;
            text-shadow: var(--text-glow);
        }
        #boot-text p { margin-bottom: 8px; }
        #boot-progress-bar-container { width: 80%; max-width: 600px; height: 25px; border: 2px solid var(--primary-color); margin-top: 25px; border-radius: 3px; padding: 2px; }
        #boot-progress-bar { width: 0%; height: 100%; background: linear-gradient(45deg, var(--primary-color), var(--secondary-color)); transition: width 0.2s linear; border-radius: 2px; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
        .nyx-logo-boot { font-size: 2.5em; margin-bottom: 25px; text-shadow: 0 0 15px var(--primary-color), 0 0 25px var(--primary-color); }
        
        /* --- Screamer --- */
        #screamer-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: rgba(10,0,0,0.95); z-index: 10001; 
            display: none; align-items: center; justify-content: center;
            overflow: hidden; backdrop-filter: blur(10px) brightness(0.5);
        }
        #screamer-image { /* Styles inchangés */ }

        /* --- Image Viewer --- */
        .image-viewer-content img { /* Styles inchangés */ }
        .ascii-art { /* Styles inchangés */ }

        /* --- Loading --- */
        .loading-dots span {
            animation: blink 1.4s infinite both; display: inline-block;
            color: var(--tertiary-color); text-shadow: 0 0 5px var(--tertiary-color);
        }
        .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.4s; }

    </style>
</head>
<body>
    <canvas id="matrix-rain"></canvas>
    <div class="scanline-overlay"></div>

    <div id="boot-screen">
        <div class="nyx-logo-boot">
<pre>
  _   _  ____  _   _ ____  
 | \ | |/ __ \| \ | |  _ \ 
 |  \| | |  | |  \| | |_) |
 | . ` | |  | | . ` |  _ < 
 | |\\  | |__| | |\\  | |_) |
 |_| \_|\____/|_| \_|____/ 
          N Y X O S         
</pre>
        </div>
        <div id="boot-text"></div>
        <div id="boot-progress-bar-container">
            <div id="boot-progress-bar"></div>
        </div>
        <p style="margin-top: 20px; font-size: 0.8em;">Initializing NyxOS v1.0 "Digital Veil"...</p>
    </div>

    <div id="desktop" style="display:none;">
        <div id="widget-header" class="widget">:: NYXNET OPERATING SYSTEM :: V1.0 :: DIGITAL VEIL ::</div>
        <div id="widget-left" class="widget">
            <h3>ÉTAT SYSTÈME</h3>
            <p>NOYAU: <span class="text-green-400">STABLE</span></p>
            <p>CRYPTO: <span class="text-green-400">ACTIF</span></p>
            <p>UPTIME: <span id="uptime">00:00:00</span></p>
            <p>ACCÈS: <span id="access-widget">Invité</span></p>
            <div id="cpu-graph"></div>
        </div>
        <div id="widget-right" class="widget">
            <h3>FLUX RÉSEAU</h3>
            <p>Proxy: <span class="text-cyan-400">ACTIF</span></p>
            <p>Oracle SIG: <span id="oracle-widget" class="text-green-400">FAIBLE</span></p>
            <p>Paquets IN: <span id="pkt-in">1337</span></p>
            <p>Paquets OUT: <span id="pkt-out">8008</span></p>
            <div id="net-graph"></div>
        </div>
        <div id="widget-footer" class="widget">
            <span id="current-time-footer">--:--:--</span>
            <span>CONNEXION SÉCURISÉE</span>
            <span>© NYXNET // NE PAS DISTRIBUER</span>
        </div>
    </div>

    <div id="screamer-overlay">
        <img id="screamer-image" src="https://placehold.co/600x400/FF0033/FFFFFF?text=SYSTEM_CORRUPTION" alt="System Corruption">
    </div>

    <script>
        // --- Musique Personnalisée ---
        // MODIFIEZ CETTE LIGNE AVEC L'URL DE VOTRE FICHIER MUSICAL (MP3, OGG, WAV).
        // Laissez vide ("") pour utiliser la musique synthétisée par défaut.
        // Assurez-vous que l'URL est accessible (CORS activé si sur un autre domaine).
        const customMusicUrl = ""; 

        // --- Digital Rain Background ---
        const canvas = document.getElementById('matrix-rain');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const katakana = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン';
        const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const nums = '0123456789';
        const alphabet = katakana + latin + nums;
        const fontSize = 16;
        const columns = canvas.width / fontSize;
        const rainDrops = [];
        for (let x = 0; x < columns; x++) { rainDrops[x] = 1; }

        function drawMatrix() {
            ctx.fillStyle = 'rgba(1, 3, 2, 0.05)'; // Fond noir bleuté très transparent
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00FF41'; // Vert Matrix
            ctx.font = fontSize + 'px monospace';

            for (let i = 0; i < rainDrops.length; i++) {
                const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
                ctx.fillText(text, i * fontSize, rainDrops[i] * fontSize);
                if (rainDrops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    rainDrops[i] = 0;
                }
                rainDrops[i]++;
            }
        }
        let matrixInterval = setInterval(drawMatrix, 40); // Ajustez la vitesse ici

        // --- Global Variables & Tone.js Setup ---
        let masterVolume = new Tone.Volume(-15).toDestination(); // Baisser un peu le volume global
        const keyClickSound = () => {
             new Tone.Synth({
                oscillator: { type: 'triangle' }, volume: -22, 
                envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.05 }
            }).connect(masterVolume).triggerAttackRelease('E2', '128n', Tone.now());
        };
        const errorSound = () => new Tone.Synth({ oscillator: {type: 'sawtooth', partials: [1, 0.5, 0.2] }, volume: -10, envelope: {attack:0.01, decay:0.3, sustain:0, release:0.2}}).connect(masterVolume).triggerAttackRelease('F#1', '8n');
        const successSound = () => new Tone.Synth({ oscillator: {type: 'sine'}, volume: -15, envelope: {attack:0.01, decay:0.1, sustain:0.1, release:0.2}}).connect(masterVolume).triggerAttackRelease('A4', '16n', Tone.now(), 0.7);
        const loginSound = () => new Tone.FMSynth({harmonicity:1.5, modulationIndex:8, detune:0, oscillator:{type:"sine"}, envelope:{attack:0.02,decay:0.2,sustain:0.3,release:0.6}, modulation:{type:"triangle"}, modulationEnvelope:{attack:0.02,decay:0.3,sustain:0.2,release:0.6}}).connect(masterVolume).triggerAttackRelease("D4", "2n");
        const screamerSound = () => new Tone.NoiseSynth({noise:{type:'white', playbackRate: 0.5}, volume: -5, envelope:{attack:0.005,decay:1.0,sustain:0,release:0.8}}).connect(masterVolume).triggerAttackRelease("1n");
        
        let backgroundMusic;
        let backgroundMusicPlayer;

        function startSynthMusic() {
            if (backgroundMusic && backgroundMusic.state === "started") return;
            const reverb = new Tone.Reverb(2.5).connect(masterVolume);
            const delay = new Tone.FeedbackDelay("8n", 0.3).connect(reverb);
            backgroundMusic = new Tone.Loop(time => {
                const notes = ["A1", "C2", "E2", "G#1"];
                const randomNote = notes[Math.floor(Math.random() * notes.length)];
                new Tone.AMSynth({ harmonicity: 1.5, oscillator: { type: "sawtooth" }, envelope: { attack: 1, decay: 0.5, sustain: 0.8, release: 2 }, modulation: { type: "sine" }, modulationEnvelope: { attack: 0.8, decay: 0.2, sustain: 0.5, release: 1 } })
                    .connect(delay).triggerAttackRelease(randomNote, "1m", time, 0.3);
            }, "3m").start(0); 
            Tone.Transport.start();
            appendToTerminal("Musique d'ambiance synthétisée activée.", 'info');
        }

        function startBackgroundMusic() {
            if (backgroundMusic && backgroundMusic.state === "started") return;
            if (backgroundMusicPlayer && backgroundMusicPlayer.state === "started") return;

            if (customMusicUrl) {
                backgroundMusicPlayer = new Tone.Player({
                    url: customMusicUrl, loop: true, volume: -10,
                }).toDestination();
                Tone.loaded().then(() => {
                    backgroundMusicPlayer.start();
                    Tone.Transport.start();
                    appendToTerminal("Musique personnalisée démarrée.", 'success');
                }).catch(err => {
                    appendToTerminal("Erreur chargement musique perso: " + err, 'error');
                    startSynthMusic(); 
                });
            } else {
                startSynthMusic(); 
            }
        }

        function stopBackgroundMusic() {
            if (backgroundMusic) {
                backgroundMusic.stop(0).dispose();
                backgroundMusic = null;
            }
            if (backgroundMusicPlayer) {
                backgroundMusicPlayer.stop(0).dispose();
                backgroundMusicPlayer = null;
            }
            Tone.Transport.stop(); // Peut arrêter d'autres choses, attention si utilisé ailleurs.
            appendToTerminal("Musique d'ambiance désactivée.", 'info');
        }


        // --- Window Manager ---
        class WindowManager {
             constructor(desktopId) {
                this.desktop = document.getElementById(desktopId);
                this.mainArea = document.createElement('div'); // Create main area
                this.mainArea.style.gridArea = 'main';
                this.mainArea.style.position = 'relative'; // Crucial for absolute positioning
                this.desktop.appendChild(this.mainArea);

                this.windows = [];
                this.zIndexCounter = 100;
                this.activeWindow = null;
            }

            createWindow(id, title, contentGenerator, options = {}) {
                const win = document.createElement('div');
                win.id = `window-${id}`;
                win.className = 'window';
                win.style.width = options.width || '600px';
                win.style.height = options.height || '400px';
                
                const mainAreaRect = this.mainArea.getBoundingClientRect();

                win.style.left = options.left || `${Math.max(10, Math.min(Math.random() * (mainAreaRect.width - parseInt(win.style.width, 10) - 20), mainAreaRect.width - parseInt(win.style.width, 10) - 10))}px`;
                win.style.top = options.top || `${Math.max(10, Math.min(Math.random() * (mainAreaRect.height - parseInt(win.style.height, 10) - 20), mainAreaRect.height - parseInt(win.style.height, 10) - 10))}px`;
                
                win.style.zIndex = this.zIndexCounter++;

                const header = document.createElement('div');
                header.className = 'window-header';
                header.innerHTML = `<span class="window-title">${title}</span>
                                    <div class="window-buttons">
                                        <span class="minimize-btn" title="Minimiser"></span>
                                        <span class="maximize-btn" title="Agrandir (Non implémenté)"></span>
                                        <span class="close-btn" title="Fermer"></span>
                                    </div>`;
                
                const content = document.createElement('div');
                content.className = 'window-content';
                
                win.appendChild(header);
                win.appendChild(content); 

                if (typeof contentGenerator === 'string') {
                    content.innerHTML = contentGenerator;
                } else {
                    contentGenerator(content, win); 
                }

                this.mainArea.appendChild(win); // Append to mainArea, not desktop
                this.windows.push(win);
                this.setActive(win);

                this.makeDraggable(win, header);
                header.querySelector('.close-btn').addEventListener('click', () => this.closeWindow(win));
                win.addEventListener('mousedown', () => this.setActive(win));
                
                return win;
            }

            setActive(win) {
                if (this.activeWindow && this.activeWindow !== win) {
                    this.activeWindow.classList.remove('active-window');
                }
                this.activeWindow = win;
                win.classList.add('active-window');
                win.style.zIndex = this.zIndexCounter++;
            }

            closeWindow(win) {
                win.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                win.style.opacity = '0';
                win.style.transform = 'scale(0.8)';
                setTimeout(() => {
                    win.remove();
                    this.windows = this.windows.filter(w => w !== win);
                    if (this.activeWindow === win) this.activeWindow = null;
                }, 300);
            }

            makeDraggable(element, handle) {
                 let offsetX, offsetY, isDragging = false;
                 const mainArea = this.mainArea; // Reference to main area

                handle.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.window-buttons')) return; 
                    isDragging = true;
                    offsetX = e.clientX - element.offsetLeft;
                    offsetY = e.clientY - element.offsetTop;
                    this.setActive(element);
                    document.body.style.cursor = 'move';
                    e.preventDefault(); 
                });
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    let newX = e.clientX - offsetX;
                    let newY = e.clientY - offsetY;
                    
                    const mainAreaRect = mainArea.getBoundingClientRect();
                    // Use mainAreaRect for boundary checks, but remember element's offset is relative to mainArea
                    newX = Math.max(0, Math.min(newX, mainAreaRect.width - element.offsetWidth));
                    newY = Math.max(0, Math.min(newY, mainAreaRect.height - element.offsetHeight));

                    element.style.left = `${newX}px`;
                    element.style.top = `${newY}px`;
                });
                document.addEventListener('mouseup', () => {
                    if(isDragging) {
                        isDragging = false;
                        document.body.style.cursor = 'default';
                    }
                });
            }
            
            getWindowContent(id) {
                const win = document.getElementById(`window-${id}`);
                return win ? win.querySelector('.window-content') : null;
            }
        }
        let windowManager;

        // --- Terminal Logic & File System ---
        let terminalOutput, terminalInput, promptElement;
        let currentUser = 'guest';
        let currentDirectory = '/';
        let accessLevel = 0; 
        const commandHistory = [];
        let historyIndex = -1;
        
        const fileSystem = {
            '/': { type: 'directory', children: ['readme.txt', 'login.sh', 'sys/', 'users/', 'docs/', 'data/'], owner: 'root', permissions: 'rwxr-xr-x' },
            '/readme.txt': { type: 'file', content: [
                "####################################################################",
                "#                NyxOS v1.0 'Digital Veil' - README                #",
                "####################################################################",
                "Bienvenue dans l'ombre. Ce système est votre portail.",
                "Utilisez 'help' pour une liste de commandes.",
                "Commencez par './login.sh'. Les indices sont partout...",
                "                                        - Mr. Nyx",
            ], owner: 'root', permissions: 'r--r--r--' },
            '/login.sh': { type: 'executable', action: (args) => attemptLogin(args), description: "Script d'authentification.", owner: 'root', permissions: 'rwx------' },
            
            '/sys/': { type: 'directory', children: ['kernel_log.txt', 'config/', 'modules/'], owner: 'root', permissions: 'rwxr-xr-x' },
            '/sys/kernel_log.txt': { type: 'file', content: ["[...]", "[INFO] AI Core (NyxCore_AI) Interface: ONLINE.", "[WARN] Anomalous energy signature detected near primary databank.", "[INFO] Oracle Chimera counter-measures: ACTIVE."], owner: 'root', permissions: 'r--r--r--' },
            '/sys/config/': { type: 'directory', children: ['network.conf', 'firewall.rules'], owner: 'root', permissions: 'rwx---r--', protected: 1 },
            '/sys/config/network.conf': { type: 'file', content: ["PROXY_CHAIN=TOR;I2P;NYX_RELAY_7", "DNS_OVER_TLS_STRICT=ENABLED"], owner: 'root', permissions: 'rw-------', protected: 2 },
            '/sys/config/firewall.rules': { type: 'file', content: ["ALLOW INBOUND ON PORT 2222", "DENY ALL OTHER INBOUND"], owner: 'root', permissions: 'rw-------', protected: 2 },
            '/sys/modules/': { type: 'directory', children: ['nyxcore_api.dll'], owner: 'root', permissions: 'rwx--x--x', protected: 1 },
            '/sys/modules/nyxcore_api.dll': { type: 'binary', content: "Binary data... // NyxCore AI Interface Library. v2.1.", owner: 'root', permissions: 'r-x------', protected: 2},

            '/users/': { type: 'directory', children: ['guest/', 'novice/', 'operator_alpha/', 'mr_nyx/'], owner: 'root', permissions: 'rwxr-xr-x' },
            '/users/guest/': { type: 'directory', children: ['welcome_message.txt'], owner: 'guest', permissions: 'rwx------' },
            '/users/guest/welcome_message.txt': { type: 'file', content: [
                "Bienvenue, Invité. Votre accès est limité.", 
                "Indice #1: Pour 'novice', le login est 'umbra_net'. Le mot de passe est le nom Français pour 'nuit' en 4 lettres, en majuscules."
                ], owner: 'guest', permissions: 'r--------'},
            
            '/users/novice/': { type: 'directory', children: ['tasks.txt', 'tools/', 'chimera_intel_alpha.dat'], owner: 'novice', permissions: 'rwx------', protected: 1 },
            '/users/novice/tasks.txt': { type: 'file', content: [
                "TÂCHES POUR NOVICE:",
                "1. Analyser '/users/novice/chimera_intel_alpha.dat'.",
                "   Indice #2: Le griffon protège l'or. Le symbole chimique est le mot de passe.",
                "2. Utiliser './tools/analyze_intel.sh ✨' sur '/data/raw_intel_omega.dat'.",
            ], owner: 'novice', permissions: 'rw-------', protected: 1 },
            '/users/novice/chimera_intel_alpha.dat': { 
                type: 'file', 
                content: ["DATA CHIFTRÉE:", "IRC: irc.nyxnet.void:6667", "Canal: #umbra_deep", "Clé: Le nom de la 'société' de Mr. Robot."], 
                encrypted: true, 
                password: "AU",
                owner: 'novice', permissions: 'r--------', protected: 1 
            },
            '/users/novice/tools/': { type: 'directory', children: ['analyze_intel.sh'], owner: 'novice', permissions: 'rwx------', protected: 1 },
            '/users/novice/tools/analyze_intel.sh': { type: 'executable', action: async (args) => await analyzeIntelFile(args), description: "✨ Analyse renseignements bruts. Usage: ./analyze_intel.sh <fichier>", owner: 'novice', permissions: 'r-x------', protected: 1},

            '/users/operator_alpha/': { type: 'directory', children: [], owner: 'operator_alpha', permissions: 'rwx------', protected: 2 },
            '/users/mr_nyx/': { type: 'directory', children: ['the_truth.img', 'kill_switch.sh'], owner: 'mr_nyx', permissions: 'rwx------', protected: 3 },
            '/users/mr_nyx/the_truth.img': { type: 'image', url: 'https://placehold.co/800x600/00FF41/0A0A0A?text=THE+TRUTH+IS+A+GLITCH', description: "Une image glitchée.", password: "fsociety", owner: 'mr_nyx', permissions: 'r--------', protected: 3 },
            '/users/mr_nyx/kill_switch.sh': { type: 'executable', action: (args) => { /* ... */ }, description: "Script de la dernière chance.", owner: 'mr_nyx', permissions: 'r-x------', protected: 3, requiresPassword: true, password: "theendisanewbeginning" },

            '/docs/': { type: 'directory', children: ['nyxnet_manifesto.txt'], owner: 'root', permissions: 'rwxr-xr-x' },
            '/docs/nyxnet_manifesto.txt': { type: 'file', content: ["Nous sommes NyxNet. Nous sommes l'ombre.", "Nous voyons la corruption.", "Nous agissons."], owner: 'root', permissions: 'r--r--r--'},

            '/data/': { type: 'directory', children: ['raw_intel_omega.dat'], owner: 'root', permissions: 'rwxr-x---', protected: 1 },
            '/data/raw_intel_omega.dat': { type: 'file', content: ["INTERCEPT: ...AURORA...PHOENIX...CHIMERA_CORE_7...", "GEO_COORDS: 34.0522° N, 118.2437° W...", "SUBJECT: \"The Alchemist\" ... LifeInvader ...", "ASSET: \"Oracle Glass Shard\" ... Vespucci Canals..."], owner: 'operator_alpha', permissions: 'r--------', protected: 1 }
        };

        // --- Le reste du JavaScript (fonctions de commandes, login, etc.) ---
        // ... (Coller le JS de la version précédente ici, mais...)
        // --- MODIFICATION DANS attemptLogin ---
        function attemptLogin(args) {
            const username = args[0];
            const password = args[1];

            if (!username || !password) {
                appendToTerminal("Usage: ./login.sh <username> <password>", 'info');
                appendToTerminal("Indice pour 'novice': voir /users/guest/welcome_message.txt", 'info');
                return;
            }

            // *** CORRECTION ICI ***
            if (username === 'novice' && password === 'NUIT') { 
                loginSound();
                currentUser = 'novice';
                accessLevel = 1;
                updatePrompt();
                appendToTerminal("Authentification réussie. Bienvenue, Novice.", 'success');
                appendToTerminal("Votre répertoire personnel est /users/novice/. Consultez vos tâches.", 'info');
            } else if (username === 'operator_alpha' && password === 'chimera_down') { 
                loginSound();
                currentUser = 'operator_alpha';
                accessLevel = 2;
                updatePrompt();
                appendToTerminal("Accès Opérateur Alpha confirmé. Protocoles de sécurité avancés activés.", 'success');
            } else if (username === 'mr_nyx' && password === 'reality_is_an_illusion_2015') { 
                loginSound();
                currentUser = 'Mr. Nyx';
                accessLevel = 3;
                updatePrompt();
                appendToTerminal("/////////////////////////////////////////////////////////////", 'error');
                appendToTerminal("ACCÈS ADMINISTRATEUR TOTAL ACCORDÉ. BIENVENUE, CRÉATEUR.", 'error');
                appendToTerminal("Le Voile est levé. Le Système est à vous.", 'error');
                appendToTerminal("/////////////////////////////////////////////////////////////", 'error');
            }
            else {
                errorSound();
                appendToTerminal("Échec de l'authentification. Identifiants incorrects ou inexistants.", 'error');
                if (Math.random() < 0.2) { 
                    appendToTerminal("Les ombres vous observent. Votre tentative a été notée.", 'warning');
                }
            }
        }
        
        // ... (Reste du JS: resolvePath, getNode, appendToTerminal, handleCommand, promptPassword, etc.) ...
        // ... (Assurez-vous que toutes les fonctions JS de la version précédente sont ici) ...
        // --- COLler ICI TOUT LE JAVASCRIPT PRÉCÉDENT, EN GARDANT LA FONCTION attemptLogin MODIFIÉE ---
        // (Pour des raisons de longueur, je ne recopie pas tout le JS, mais il doit être présent)
        // Inclure : WindowManager, resolvePath, getNode, updatePrompt, appendToTerminal,
        // analyzeIntelWithGemini, analyzeIntelFile, handleCommand, getUserRole, hasPermissions,
        // promptPassword, triggerScreamer, runBootSequence, updateStatusBar, Initialisation...

        // --- Assurez-vous que handleCommand est à jour ---
        async function handleCommand(cmd) {
            const [command, ...args] = cmd.trim().split(' ');
            appendToTerminal(`${promptElement.innerHTML.replace(/<[^>]*>?/gm, '')}${cmd}`); 
            keyClickSound();

            if (command.startsWith('./')) {
                const scriptName = command.substring(2);
                const scriptPath = currentDirectory + scriptName;
                const scriptNode = getNode(scriptPath); // Utiliser le chemin complet
                if (scriptNode && scriptNode.type === 'executable') {
                    if (hasPermissions(scriptNode, 'x')) {
                        if (scriptNode.requiresPassword) {
                            const enteredPassword = await promptPassword(`Mot de passe pour ${scriptName}:`);
                            if (enteredPassword === scriptNode.password) {
                                successSound();
                                await scriptNode.action(args);
                            } else {
                                errorSound();
                                appendToTerminal("Mot de passe incorrect.", 'error');
                            }
                        } else {
                           await scriptNode.action(args);
                        }
                    } else {
                        errorSound();
                        appendToTerminal(`Erreur: Permission refusée pour exécuter '${scriptName}'.`, 'error');
                    }
                    return;
                } else {
                     errorSound();
                     appendToTerminal(`Erreur: Script non trouvé ou non exécutable '${scriptName}'.`, 'error');
                     return;
                }
            }


            switch (command.toLowerCase()) {
                case 'help':
                    appendToTerminal("Commandes disponibles:", 'info');
                    appendToTerminal("  help          - Affiche cette aide.");
                    appendToTerminal("  ls [chemin]   - Liste fichiers/répertoires.");
                    appendToTerminal("  cd <chemin>   - Change de répertoire.");
                    appendToTerminal("  cat <fichier> - Affiche contenu fichier.");
                    appendToTerminal("  pwd           - Affiche répertoire actuel.");
                    appendToTerminal("  whoami        - Affiche utilisateur actuel.");
                    appendToTerminal("  accesslevel   - Affiche niveau d'accès actuel.");
                    appendToTerminal("  clear         - Efface l'écran.");
                    appendToTerminal("  exit          - Quitte la session (simulé).");
                    appendToTerminal("  ./<script>    - Exécute un script local (ex: ./login.sh, ./analyze_intel.sh ✨).");
                    appendToTerminal("  view <image>  - Ouvre une image (si type 'image').");
                    appendToTerminal("  play <audio>  - Joue un fichier audio (si type 'audio').");
                    appendToTerminal("  sudo <cmd>    - (Simulé) Tente d'exécuter une commande avec privilèges root.", 'warning');
                    appendToTerminal("  music [on|off]- Active/désactive la musique d'ambiance.", 'info');
                    appendToTerminal("  setmusic <url>- Définit une URL pour la musique (temporaire).", 'info');
                    break;
                case 'ls':
                    const pathToList = args[0] ? resolvePath(args[0]) : currentDirectory;
                    const nodeToList = getNode(pathToList);
                    if (nodeToList && nodeToList.type === 'directory') {
                        if (nodeToList.protected > accessLevel) {
                            errorSound();
                            appendToTerminal(`Erreur: Accès refusé à '${pathToList}'. Niveau ${nodeToList.protected} requis.`, 'error');
                        } else if (!hasPermissions(nodeToList, 'r')) {
                            errorSound();
                            appendToTerminal(`Erreur: Permission de lecture refusée pour '${pathToList}'.`, 'error');
                        }
                        else {
                            let listOutput = `Contenu de <span class="dirname">${pathToList}</span>:\n`;
                            nodeToList.children.forEach(child => {
                                const childPath = pathToList + child;
                                const childNode = getNode(childPath);
                                if (childNode) {
                                    const isDir = childNode.type === 'directory';
                                    const nameClass = isDir ? 'dirname' : 'filename';
                                    const perms = childNode.permissions || '---------';
                                    const owner = childNode.owner || 'unknown';
                                    let displayName = child;
                                    if (childNode.type === 'executable' && childNode.description && childNode.description.includes('✨')) {
                                        displayName = child + ' ✨';
                                    }
                                    listOutput += `  <span class="text-gray-500">${perms} ${owner.padEnd(8)}</span> <span class="${nameClass}">${displayName}${isDir ? '/' : ''}</span>\n`;
                                }
                            });
                            appendToTerminal(listOutput.trim(), '', true);
                        }
                    } else {
                        errorSound();
                        appendToTerminal(`Erreur: Répertoire non trouvé ou invalide '${pathToList}'`, 'error');
                    }
                    break;
                case 'cd':
                    if (!args[0]) { appendToTerminal("Usage: cd <répertoire>", 'info'); break; }
                    const pathToChange = resolvePath(args[0]);
                    const nodeToChange = getNode(pathToChange);
                    if (nodeToChange && nodeToChange.type === 'directory') {
                        if (nodeToChange.protected > accessLevel) {
                            errorSound();
                            appendToTerminal(`Erreur: Accès refusé à '${pathToChange}'. Niveau ${nodeToChange.protected} requis.`, 'error');
                        } else if (!hasPermissions(nodeToChange, 'x')) { 
                             errorSound();
                             appendToTerminal(`Erreur: Permission d'exécution refusée pour '${pathToChange}'.`, 'error');
                        } else {
                            currentDirectory = pathToChange;
                            updatePrompt();
                        }
                    } else {
                        errorSound();
                        appendToTerminal(`Erreur: Répertoire non trouvé '${args[0]}'`, 'error');
                    }
                    break;
                case 'cat':
                    if (!args[0]) { appendToTerminal("Usage: cat <fichier>", 'info'); break; }
                    const filePath = resolvePath(args[0], currentDirectory).slice(0,-1); 
                    const fileNode = getNode(filePath);

                    if (fileNode && fileNode.type === 'file') {
                        if (fileNode.protected > accessLevel) {
                            errorSound();
                            appendToTerminal(`Erreur: Accès refusé à '${filePath}'. Niveau ${fileNode.protected} requis.`, 'error');
                        } else if (!hasPermissions(fileNode, 'r')) {
                            errorSound();
                            appendToTerminal(`Erreur: Permission de lecture refusée pour '${filePath}'.`, 'error');
                        } else if (fileNode.encrypted) {
                            const password = await promptPassword(`Mot de passe pour ${args[0]}:`);
                            if (password === fileNode.password) {
                                successSound();
                                appendToTerminal(`Contenu de <span class="filename">${args[0]}</span> (déchiffré):`, 'info', true);
                                appendToTerminal(fileNode.content.join('\n'));
                            } else {
                                errorSound();
                                appendToTerminal("Mot de passe incorrect.", 'error');
                            }
                        } else {
                            appendToTerminal(`Contenu de <span class="filename">${args[0]}</span>:`, 'info', true);
                            appendToTerminal(fileNode.content.join('\n'));
                        }
                    } else if (fileNode && (fileNode.type === 'binary' || fileNode.type === 'image' || fileNode.type === 'audio')) {
                        appendToTerminal(`'${args[0]}' est un fichier ${fileNode.type}. Utilisez 'view' pour les images, 'play' pour l'audio, ou exécutez les binaires.`, 'warning');
                    } else {
                        errorSound();
                        appendToTerminal(`Erreur: Fichier non trouvé ou n'est pas un fichier texte '${args[0]}'`, 'error');
                    }
                    break;
                case 'view': 
                    if (!args[0]) { appendToTerminal("Usage: view <fichier_image>", 'info'); break; }
                    const imagePath = resolvePath(args[0], currentDirectory).slice(0,-1);
                    const imageNode = getNode(imagePath);
                    if (imageNode && imageNode.type === 'image') {
                        if (imageNode.protected > accessLevel) {
                            errorSound(); appendToTerminal(`Accès refusé. Niveau ${imageNode.protected} requis.`, 'error'); break;
                        }
                        if (imageNode.password) {
                            const imgPassword = await promptPassword(`Mot de passe pour ${args[0]}:`);
                            if (imgPassword !== imageNode.password) {
                                errorSound(); appendToTerminal("Mot de passe incorrect.", 'error'); break;
                            }
                            successSound();
                        }
                        windowManager.createWindow(`image-viewer-${Date.now()}`, `Image: ${args[0]}`, (contentDiv) => {
                            contentDiv.classList.add('image-viewer-content');
                            if (imageNode.url) {
                                const img = document.createElement('img');
                                img.src = imageNode.url;
                                img.alt = imageNode.description || args[0];
                                contentDiv.appendChild(img);
                            } else if (imageNode.ascii) { 
                                const pre = document.createElement('pre');
                                pre.className = 'ascii-art';
                                pre.textContent = imageNode.ascii.join('\n');
                                contentDiv.appendChild(pre);
                            }
                            appendToTerminal(imageNode.description || `Affichage de ${args[0]}.`, 'info');
                        }, { width: '500px', height: 'auto' });
                    } else {
                        errorSound(); appendToTerminal(`'${args[0]}' n'est pas un fichier image visualisable.`, 'error');
                    }
                    break;
                case 'play': 
                     if (!args[0]) { appendToTerminal("Usage: play <fichier_audio>", 'info'); break; }
                    const audioPath = resolvePath(args[0], currentDirectory).slice(0,-1);
                    const audioNode = getNode(audioPath);
                    if (audioNode && audioNode.type === 'audio') {
                        if (audioNode.protected > accessLevel) {
                            errorSound(); appendToTerminal(`Accès refusé. Niveau ${audioNode.protected} requis.`, 'error'); break;
                        }
                         if (audioNode.soundEffect && typeof audioNode.soundEffect === 'function') {
                            audioNode.soundEffect();
                            appendToTerminal(audioNode.description || `Lecture de ${args[0]}...`, 'info');
                        } else {
                            appendToTerminal(`Aucun effet sonore défini pour ${args[0]}.`, 'warning');
                        }
                    } else {
                        errorSound(); appendToTerminal(`'${args[0]}' n'est pas un fichier audio jouable.`, 'error');
                    }
                    break;
                case 'pwd': appendToTerminal(currentDirectory); break;
                case 'whoami': appendToTerminal(currentUser); break;
                case 'accesslevel': appendToTerminal(`Niveau d'accès actuel: ${accessLevel} (${getUserRole(accessLevel)})`, 'info'); break;
                case 'clear': terminalOutput.innerHTML = ''; break;
                case 'exit': /* ... */ break;
                case 'sudo': /* ... */ break;
                case 'music':
                    if (args[0] === 'on') { startBackgroundMusic(); } 
                    else if (args[0] === 'off') { stopBackgroundMusic(); } 
                    else { appendToTerminal("Usage: music [on|off]", 'info'); }
                    break;
                case 'setmusic':
                    if (args[0]) {
                        // Pour cette démo, on ne change pas la variable globale, on essaie de jouer la nouvelle URL
                        appendToTerminal(`Tentative de chargement de la musique depuis : ${args[0]}`, 'info');
                        if (backgroundMusicPlayer || backgroundMusic) stopBackgroundMusic();
                        const tempPlayer = new Tone.Player({ url: args[0], loop: true, volume: -10 }).toDestination();
                        Tone.loaded().then(() => { tempPlayer.start(); backgroundMusicPlayer = tempPlayer; Tone.Transport.start(); appendToTerminal("Nouvelle musique démarrée.", 'success'); }).catch(err => { appendToTerminal("Erreur chargement: " + err, 'error'); });
                    } else { appendToTerminal("Usage: setmusic <url>", 'info'); }
                    break;
                case '': break; 
                default:
                    errorSound();
                    appendToTerminal(`Commande inconnue: '${command}'. Tapez 'help'.`, 'error');
            }
        }
        function getUserRole(level) { /* ... */ return 'Role';}
        function hasPermissions(node, permType) { /* ... */ return true; }
        async function promptPassword(message) { /* ... */ return 'password'; }
        function triggerScreamer(imageUrl, duration = 2000) { /* ... */ }
        function updateStatusBar() { /* ... */ }
        async function runBootSequence() { /* ... */ 
            setTimeout(() => {
                bootScreen.style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-out'; 
                bootScreen.style.opacity = '0';
                bootScreen.style.transform = 'scale(1.2)'; 
                setTimeout(() => {
                    bootScreen.style.display = 'none';
                    desktop.style.display = 'grid'; 
                    windowManager = new WindowManager('desktop');
                    const terminalWindow = windowManager.createWindow('main-terminal', 'NyxNet Secure Shell (NSS)', (contentDiv, windowElement) => {
                        contentDiv.innerHTML = `
                            <div id="terminal-output" style="height: calc(100% - 40px); overflow-y: auto; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;"></div>
                            <div class="prompt-line p-1 border-t border-gray-700/50" style="height: 30px;">
                                <span id="prompt" class="prompt"></span>
                                <input type="text" id="terminal-input" class="terminal-input" autofocus placeholder="Entrez votre commande...">
                            </div>
                        `;
                        terminalOutput = contentDiv.querySelector('#terminal-output');
                        terminalInput = contentDiv.querySelector('#terminal-input');
                        promptElement = contentDiv.querySelector('#prompt');
                        
                        appendToTerminal("NyxOS v1.0 'Digital Veil' initialisé.", 'info');
                        appendToTerminal("Tapez 'cat /readme.txt' ou 'help' pour commencer.", 'info');
                        updatePrompt();

                        terminalInput.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                const command = terminalInput.value;
                                if (command.trim() !== "") commandHistory.unshift(command);
                                historyIndex = -1;
                                handleCommand(command);
                                terminalInput.value = '';
                            } else if (e.key === 'ArrowUp') {
                                e.preventDefault();
                                if (commandHistory.length > 0) {
                                    historyIndex = Math.min(historyIndex + 1, commandHistory.length - 1);
                                    terminalInput.value = commandHistory[historyIndex];
                                }
                            } else if (e.key === 'ArrowDown') {
                                e.preventDefault();
                                if (commandHistory.length > 0) {
                                    historyIndex = Math.max(historyIndex - 1, -1);
                                    terminalInput.value = (historyIndex === -1) ? '' : commandHistory[historyIndex];
                                }
                            } else if (e.key.length === 1 || e.key === "Backspace" || e.key === "Delete") { 
                                keyClickSound(); 
                            }
                        });
                    }, { width: '60vw', height: '65vh', left: '50px', top: '50px' }); // Positionnement initial
                    
                    if (terminalWindow && terminalInput) {
                        terminalWindow.addEventListener('click', (e) => {
                            if (!e.target.closest('.window-header')) {
                                if(terminalInput) terminalInput.focus();
                            }
                        });
                    }
                    setInterval(updateStatusBar, 1500); // Update status bar every 1.5 second
                }, 500); 
            }, 500);
        }

        document.body.addEventListener('click', async () => {
            if (Tone.context.state !== 'running') {
                await Tone.start();
                console.log("AudioContext démarré par interaction utilisateur.");
            }
        }, { once: true });

        window.onload = () => {
            runBootSequence();
            // Start updating widgets once DOM is loaded
            setInterval(() => {
                document.getElementById('uptime').textContent = new Date(performance.now()).toISOString().substr(11, 8);
                document.getElementById('pkt-in').textContent = parseInt(document.getElementById('pkt-in').textContent) + Math.floor(Math.random() * 50);
                document.getElementById('pkt-out').textContent = parseInt(document.getElementById('pkt-out').textContent) + Math.floor(Math.random() * 10);
                document.getElementById('access-widget').textContent = getUserRole(accessLevel);
                document.getElementById('oracle-widget').textContent = document.getElementById('oracle-sig').textContent;
                document.getElementById('oracle-widget').className = document.getElementById('oracle-sig').className;
                
                // Animate graph bars
                document.querySelectorAll('.graph-bar').forEach(bar => {
                   bar.style.left = `${Math.random() * 95}%`;
                   bar.style.height = `${Math.random() * 80 + 10}%`;
                   bar.style.background = Math.random() > 0.7 ? 'var(--secondary-color)' : 'var(--primary-color)';
                });
            }, 1500);
             // Initial graph bars
            const cpuGraph = document.getElementById('cpu-graph');
            const netGraph = document.getElementById('net-graph');
            for(let i=0; i<20; i++) {
                const bar1 = document.createElement('div'); bar1.className = 'graph-bar'; cpuGraph.appendChild(bar1);
                const bar2 = document.createElement('div'); bar2.className = 'graph-bar'; netGraph.appendChild(bar2);
            }
        };


    </script>
</body>
</html>
