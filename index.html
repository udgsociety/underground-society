<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NyxOS v0.9 - Obsidian Veil</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&family=Roboto+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #00FF41; /* Vert phosphorescent principal */
            --secondary-color: #0DFFFF; /* Cyan électrique */
            --tertiary-color: #9D00FF; /* Violet néon */
            --error-color: #FF0033; /* Rouge vif */
            --warning-color: #FFD700; /* Or/Jaune pour avertissements */
            
            --background-color: #030508; /* Noir bleuté très sombre */
            --background-glow: rgba(0, 255, 65, 0.05); /* Aura verte subtile */
            
            --window-bg-color: rgba(10, 20, 30, 0.8); /* Fond de fenêtre bleu-noir semi-transparent */
            --window-border-color: var(--secondary-color);
            --window-header-bg: rgba(0, 30, 40, 0.9);

            --font-main: 'Roboto Mono', monospace;
            --font-display: 'Share Tech Mono', monospace; /* Pour les titres, prompts */
            --font-pixel: 'VT323', monospace; /* Pour les éléments rétro */

            --text-glow-primary: 0 0 5px var(--primary-color), 0 0 10px var(--primary-color);
            --text-glow-secondary: 0 0 5px var(--secondary-color), 0 0 10px var(--secondary-color);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 10px var(--background-glow), 0 0 20px var(--background-glow); }
            50% { box-shadow: 0 0 20px var(--background-glow), 0 0 40px var(--background-glow); }
        }
        
        @keyframes subtleScanline {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        body {
            font-family: var(--font-main);
            background-color: var(--background-color);
            color: var(--primary-color);
            overflow: hidden;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            animation: fadeIn 1.5s ease-out;
            /* Nouveau fond animé */
            background: 
                linear-gradient(rgba(0,0,0,0.95), rgba(0,0,0,0.95)),
                repeating-linear-gradient(
                    0deg,
                    rgba(var(--secondary-color-rgb, 13, 255, 255), 0.02),
                    rgba(var(--secondary-color-rgb, 13, 255, 255), 0.02) 1px,
                    transparent 1px,
                    transparent 60px
                ),
                repeating-linear-gradient(
                    90deg,
                    rgba(var(--primary-color-rgb, 0, 255, 65), 0.02),
                    rgba(var(--primary-color-rgb, 0, 255, 65), 0.02) 1px,
                    transparent 1px,
                    transparent 60px
                ),
                var(--background-color);
            background-size: cover, 60px 60px, 60px 60px, cover;
            animation: pulseGlow 10s infinite alternate, subtleScanline 20s linear infinite;
        }
        /* Pour que les variables RGB fonctionnent avec rgba() */
        body::before {
            content: "";
            position: absolute;
            top:0; left:0; width:1px; height:1px;
            --primary-color-rgb: 0, 255, 65;
            --secondary-color-rgb: 13, 255, 255;
        }


        .scanline-overlay { /* Conserver pour un effet de moniteur global */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(
                to bottom,
                rgba(20,20,30,0) 50%,
                rgba(0,0,0,0.25) 51%,
                rgba(20,20,30,0) 52%
            );
            background-size: 100% 3px; /* Lignes plus fines */
            animation: scanlines 0.2s linear infinite; /* Animation plus rapide pour effet de rafraîchissement */
            opacity: 0.2; /* Plus subtil */
            z-index: 9999;
        }

        @keyframes scanlines {
            0% { background-position: 0 0; }
            100% { background-position: 0 3px; }
        }
        
        #desktop {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
            padding: 20px; /* Espace pour les éléments décoratifs */
            display: grid; /* Pour positionner les éléments décoratifs */
            grid-template-columns: 1fr auto 1fr;
            grid-template-rows: auto 1fr auto;
        }
        
        /* Éléments décoratifs pour le bureau */
        .desktop-deco {
            position: absolute;
            opacity: 0.3;
            font-family: var(--font-pixel);
            font-size: 0.8em;
            color: var(--secondary-color);
            pointer-events: none; /* Pour ne pas interférer avec les clics */
            text-shadow: var(--text-glow-secondary);
        }
        #deco-top-left { top: 10px; left: 10px; writing-mode: vertical-rl; }
        #deco-bottom-right { bottom: 10px; right: 10px; text-align: right;}
        #deco-status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 5px 15px;
            background-color: rgba(0,10,15,0.8);
            border-top: 1px solid var(--secondary-color);
            font-family: var(--font-display);
            font-size: 0.9em;
            color: var(--secondary-color);
            display: flex;
            justify-content: space-between;
            z-index: 50; /* Sous les fenêtres mais au-dessus du fond */
            backdrop-filter: blur(3px);
        }
        .status-item { animation: flicker 5s infinite alternate; }
        @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }


        .window {
            position: absolute;
            background-color: var(--window-bg-color);
            border: 1px solid var(--window-border-color);
            border-radius: 8px; /* Coins plus arrondis */
            box-shadow: 0 0 15px rgba(var(--secondary-color-rgb), 0.4), 
                        0 0 30px rgba(var(--secondary-color-rgb), 0.2),
                        inset 0 0 5px rgba(var(--primary-color-rgb), 0.1);
            display: flex;
            flex-direction: column;
            min-width: 350px; /* Légèrement plus large */
            min-height: 250px;
            backdrop-filter: blur(8px) saturate(120%); /* Effet verre dépoli plus prononcé */
            resize: both; 
            overflow: hidden; 
            transition: box-shadow 0.3s ease, border-color 0.3s ease; /* Transitions douces */
        }
        .window:focus-within, .window.active-window { /* Style pour la fenêtre active */
             border-color: var(--primary-color);
             box-shadow: 0 0 25px rgba(var(--primary-color-rgb), 0.6), 
                        0 0 50px rgba(var(--primary-color-rgb), 0.3),
                        inset 0 0 10px rgba(var(--secondary-color-rgb), 0.2);
        }


        .window-header {
            background-color: var(--window-header-bg);
            padding: 8px 12px; /* Plus d'espacement */
            cursor: move;
            border-bottom: 1px solid var(--window-border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top-left-radius: 7px;
            border-top-right-radius: 7px;
            text-shadow: 0 0 3px rgba(0,0,0,0.5); /* Ombre pour le texte du titre */
        }

        .window-title {
            font-family: var(--font-display);
            font-size: 1.3em; /* Titre plus grand */
            color: var(--primary-color);
            text-shadow: var(--text-glow-primary);
        }

        .window-buttons span {
            display: inline-block;
            width: 12px; /* Boutons plus visibles */
            height: 12px;
            border-radius: 50%;
            margin-left: 6px;
            cursor: pointer;
            transition: transform 0.2s ease, opacity 0.2s ease;
            border: 1px solid rgba(0,0,0,0.2);
        }
        .window-buttons span:hover { transform: scale(1.2); opacity: 1; }
        .window-buttons .close-btn { background-color: var(--error-color); box-shadow: 0 0 8px var(--error-color); }
        .window-buttons .minimize-btn { background-color: var(--warning-color); box-shadow: 0 0 8px var(--warning-color); }
        /* Ajout d'un bouton "maximize" pour le style */
        .window-buttons .maximize-btn { background-color: var(--secondary-color); box-shadow: 0 0 8px var(--secondary-color); }


        .window-content {
            flex-grow: 1;
            padding: 15px; /* Plus d'espacement interne */
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) rgba(0,0,0,0.3);
            line-height: 1.6; /* Meilleure lisibilité */
        }
        .window-content::-webkit-scrollbar { width: 10px; }
        .window-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 5px; }
        .window-content::-webkit-scrollbar-thumb { background-color: var(--primary-color); border-radius: 5px; border: 2px solid rgba(0,0,0,0.2); }
        .window-content::-webkit-scrollbar-thumb:hover { background-color: var(--secondary-color); }


        /* Terminal Specific */
        #terminal-output {
            white-space: pre-wrap;
            word-wrap: break-word;
            /* Effet de texte cathodique subtil */
            text-shadow: 0 0 1px rgba(var(--primary-color-rgb), 0.5);
        }
        .prompt-line { display: flex; align-items: center; margin-top: 5px; }
        .prompt { 
            font-family: var(--font-display);
            margin-right: 10px; 
            font-size: 1.1em;
        }
        .terminal-input {
            background-color: transparent;
            border: none;
            color: var(--primary-color);
            flex-grow: 1;
            outline: none;
            caret-color: var(--tertiary-color); /* Caret violet */
            font-family: inherit; 
            font-size: 1.1em; /* Input plus grand */
            text-shadow: var(--text-glow-primary);
        }
        .terminal-input::placeholder { color: rgba(var(--primary-color-rgb), 0.4); }


        .error { color: var(--error-color); font-weight: bold; text-shadow: 0 0 5px var(--error-color); }
        .info { color: var(--secondary-color); text-shadow: 0 0 3px var(--secondary-color); }
        .success { color: #66FF66; /* Vert plus vif pour succès */ text-shadow: 0 0 5px #66FF66; } 
        .warning { color: var(--warning-color); font-weight: bold; text-shadow: 0 0 5px var(--warning-color); }
        .filename { color: #A0FFA0; /* Vert pastel pour fichiers */ } 
        .dirname { color: #A0D8FF; /* Bleu pastel pour dossiers */ } 

        /* Boot Sequence Styling */
        #boot-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            color: var(--primary-color);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: var(--font-pixel);
            font-size: 1.6em; /* Texte de boot plus grand */
            padding: 20px;
            text-align: left;
            text-shadow: var(--text-glow-primary);
        }
        #boot-text p { margin-bottom: 8px; }
        #boot-progress-bar-container { width: 80%; max-width: 600px; height: 25px; border: 2px solid var(--primary-color); margin-top: 25px; border-radius: 3px; padding: 2px; }
        #boot-progress-bar { width: 0%; height: 100%; background: 
            linear-gradient(45deg, var(--primary-color), var(--secondary-color)); 
            transition: width 0.2s linear; border-radius: 2px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .nyx-logo-boot { font-size: 2.5em; margin-bottom: 25px; text-shadow: 0 0 15px var(--primary-color), 0 0 25px var(--primary-color); }
        
        /* Screamer Styling */
        #screamer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(10,0,0,0.95); /* Fond rouge sombre pour screamer */
            z-index: 10001; 
            display: none; 
            align-items: center;
            justify-content: center;
            overflow: hidden;
            backdrop-filter: blur(10px) brightness(0.5);
        }
        #screamer-image {
            max-width: 80%; /* Image un peu plus petite pour voir le fond */
            max-height: 80%;
            object-fit: contain;
            animation: glitch-image-intense 0.3s infinite steps(3, end), pulseScreamer 1s infinite alternate;
            border: 4px solid var(--error-color);
            box-shadow: 0 0 50px var(--error-color), 0 0 100px var(--error-color);
            filter: saturate(200%) contrast(150%);
        }
        @keyframes glitch-image-intense {
            0% { transform: translate(0,0) skew(0); }
            25% { transform: translate(-10px, 10px) skew(-8deg); }
            50% { transform: translate(10px, -10px) skew(8deg); }
            75% { transform: translate(-5px, 5px) skew(-4deg); }
            100% { transform: translate(5px, -5px) skew(4deg); }
        }
        @keyframes pulseScreamer {
            from { filter: brightness(0.8) saturate(150%); }
            to { filter: brightness(1.2) saturate(250%); }
        }


        /* Image Viewer Styling */
        .image-viewer-content img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
            margin: 0 auto;
            border: 2px solid var(--secondary-color);
            box-shadow: 0 0 15px var(--secondary-color);
        }
        .ascii-art {
            font-family: var(--font-pixel); 
            white-space: pre;
            line-height: 1;
            font-size: 0.9em; 
            color: var(--primary-color); /* Assurer la couleur pour l'art ASCII */
            text-shadow: var(--text-glow-primary);
        }

        /* Loading Indicator */
        .loading-dots {
            font-family: var(--font-display);
        }
        .loading-dots span {
            animation: blink 1.4s infinite both;
            display: inline-block;
            color: var(--tertiary-color); /* Points de chargement violets */
            text-shadow: 0 0 5px var(--tertiary-color);
        }
        .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes blink {
            0% { opacity: .2; transform: translateY(0); }
            20% { opacity: 1; transform: translateY(-2px); }
            100% { opacity: .2; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="scanline-overlay"></div>

    <div id="boot-screen">
        <div class="nyx-logo-boot">
<pre>
  _   _  ____  _   _ ____  
 | \ | |/ __ \| \ | |  _ \ 
 |  \| | |  | |  \| | |_) |
 | . ` | |  | | . ` |  _ < 
 | |\\  | |__| | |\\  | |_) |
 |_| \_|\____/|_| \_|____/ 
          N Y X O S         
</pre>
        </div>
        <div id="boot-text"></div>
        <div id="boot-progress-bar-container">
            <div id="boot-progress-bar"></div>
        </div>
        <p style="margin-top: 20px; font-size: 0.8em;">Initializing NyxOS v0.9 "Obsidian Veil"...</p>
    </div>

    <div id="desktop">
        <div id="deco-top-left" class="desktop-deco">
            NYX_OS_KERNEL_V0.9<br>
            STATUS: STABLE<br>
            ENCRYPTION: AES-8192<br>
            THREAT_LEVEL: NOMINAL
        </div>
        <div id="deco-bottom-right" class="desktop-deco">
            :: NYXNET :: UMBRAL VEIL PROTOCOL ::<br>
            :: SECURE_NODE_7B3D :: ACTIVE_SINCE_CYCLE_0x2A ::
        </div>
         <div id="deco-status-bar">
            <span class="status-item">UTIL. CPU: <span id="cpu-load">13.37</span>%</span>
            <span class="status-item">TRAFIC RÉSEAU: <span id="net-traffic">42.69</span> Kbps</span>
            <span class="status-item">SIG. ORACLE: <span id="oracle-sig" class="text-green-400">FAIBLE</span></span>
            <span class="status-item" id="current-time">--:--:--</span>
        </div>
    </div>

    <div id="screamer-overlay">
        <img id="screamer-image" src="https://placehold.co/600x400/FF0033/FFFFFF?text=SYSTEM_CORRUPTION" alt="System Corruption">
    </div>

    <script>
        // --- Global Variables & Tone.js Setup ---
        let masterVolume = new Tone.Volume(-12).toDestination(); 
        const keyClickSound = () => {
            new Tone.Synth({
                oscillator: { type: 'triangle' }, // Son plus doux
                volume: -22, // Encore plus discret
                envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.05 }
            }).connect(masterVolume).triggerAttackRelease('E2', '128n', Tone.now()); // Note plus haute, durée très courte
        };
        const errorSound = () => new Tone.Synth({ oscillator: {type: 'sawtooth', partials: [1, 0.5, 0.2] }, volume: -10, envelope: {attack:0.01, decay:0.3, sustain:0, release:0.2}}).connect(masterVolume).triggerAttackRelease('F#1', '8n');
        const successSound = () => new Tone.Synth({ oscillator: {type: 'sine'}, volume: -15, envelope: {attack:0.01, decay:0.1, sustain:0.1, release:0.2}}).connect(masterVolume).triggerAttackRelease('A4', '16n', Tone.now(), 0.7);
        const loginSound = () => new Tone.FMSynth({harmonicity:1.5, modulationIndex:8, detune:0, oscillator:{type:"sine"}, envelope:{attack:0.02,decay:0.2,sustain:0.3,release:0.6}, modulation:{type:"triangle"}, modulationEnvelope:{attack:0.02,decay:0.3,sustain:0.2,release:0.6}}).connect(masterVolume).triggerAttackRelease("D4", "2n");
        const screamerSound = () => new Tone.NoiseSynth({noise:{type:'white', playbackRate: 0.5}, volume: -5, envelope:{attack:0.005,decay:1.0,sustain:0,release:0.8}}).connect(masterVolume).triggerAttackRelease("1n");
        
        let backgroundMusic;
        function startBackgroundMusic() {
            if (backgroundMusic && backgroundMusic.state === "started") return;
            const reverb = new Tone.Reverb(2.5).connect(masterVolume); // Ajout d'une réverbération
            const delay = new Tone.FeedbackDelay("8n", 0.3).connect(reverb); // Ajout d'un délai

            backgroundMusic = new Tone.Loop(time => {
                const notes = ["A1", "C2", "E2", "G#1"];
                const randomNote = notes[Math.floor(Math.random() * notes.length)];
                new Tone.AMSynth({
                    harmonicity: 1.5,
                    detune: 0,
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 1, decay: 0.5, sustain: 0.8, release: 2 },
                    modulation: { type: "sine" },
                    modulationEnvelope: { attack: 0.8, decay: 0.2, sustain: 0.5, release: 1 }
                }).connect(delay).triggerAttackRelease(randomNote, "1m", time, 0.3); // Volume plus bas pour l'ambiance
            }, "3m").start(0); 
            Tone.Transport.start();
            console.log("Background music started with effects.");
        }


        // --- Window Manager ---
        class WindowManager {
            constructor(desktopId) {
                this.desktop = document.getElementById(desktopId);
                this.windows = [];
                this.zIndexCounter = 100;
                this.activeWindow = null;
            }

            createWindow(id, title, contentGenerator, options = {}) {
                const win = document.createElement('div');
                win.id = `window-${id}`;
                win.className = 'window';
                win.style.width = options.width || '600px';
                win.style.height = options.height || '400px';
                
                // Positionnement initial aléatoire mais intelligent
                const desktopWidth = this.desktop.offsetWidth;
                const desktopHeight = this.desktop.offsetHeight;
                const winWidth = parseInt(win.style.width, 10);
                const winHeight = parseInt(win.style.height, 10);

                win.style.left = options.left || `${Math.max(20, Math.min(Math.random() * (desktopWidth - winWidth - 40), desktopWidth - winWidth - 20))}px`;
                win.style.top = options.top || `${Math.max(20, Math.min(Math.random() * (desktopHeight - winHeight - 80), desktopHeight - winHeight - 40))}px`; // Moins 80 pour la barre de statut
                
                win.style.zIndex = this.zIndexCounter++;

                const header = document.createElement('div');
                header.className = 'window-header';
                header.innerHTML = `<span class="window-title">${title}</span>
                                    <div class="window-buttons">
                                        <span class="minimize-btn" title="Minimiser"></span>
                                        <span class="maximize-btn" title="Agrandir (Non implémenté)"></span>
                                        <span class="close-btn" title="Fermer"></span>
                                    </div>`;
                
                const content = document.createElement('div');
                content.className = 'window-content';
                
                win.appendChild(header);
                win.appendChild(content); 

                if (typeof contentGenerator === 'string') {
                    content.innerHTML = contentGenerator;
                } else {
                    contentGenerator(content, win); 
                }

                this.desktop.appendChild(win);
                this.windows.push(win);
                this.setActive(win);

                this.makeDraggable(win, header);
                header.querySelector('.close-btn').addEventListener('click', () => this.closeWindow(win));
                win.addEventListener('mousedown', () => this.setActive(win));
                
                return win;
            }

            setActive(win) {
                if (this.activeWindow && this.activeWindow !== win) {
                    this.activeWindow.classList.remove('active-window');
                }
                this.activeWindow = win;
                win.classList.add('active-window');
                win.style.zIndex = this.zIndexCounter++;
            }

            closeWindow(win) {
                win.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                win.style.opacity = '0';
                win.style.transform = 'scale(0.8)';
                setTimeout(() => {
                    win.remove();
                    this.windows = this.windows.filter(w => w !== win);
                    if (this.activeWindow === win) this.activeWindow = null;
                }, 300);
            }

            makeDraggable(element, handle) {
                let offsetX, offsetY, isDragging = false;
                handle.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.window-buttons')) return; // Ne pas glisser si on clique sur les boutons
                    isDragging = true;
                    offsetX = e.clientX - element.offsetLeft;
                    offsetY = e.clientY - element.offsetTop;
                    this.setActive(element);
                    document.body.style.cursor = 'move';
                    e.preventDefault(); 
                });
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    let newX = e.clientX - offsetX;
                    let newY = e.clientY - offsetY;
                    
                    const desktopRect = this.desktop.getBoundingClientRect();
                    newX = Math.max(0, Math.min(newX, desktopRect.width - element.offsetWidth));
                    newY = Math.max(0, Math.min(newY, desktopRect.height - element.offsetHeight));

                    element.style.left = `${newX}px`;
                    element.style.top = `${newY}px`;
                });
                document.addEventListener('mouseup', () => {
                    if(isDragging) {
                        isDragging = false;
                        document.body.style.cursor = 'default';
                    }
                });
            }
            
            getWindowContent(id) {
                const win = document.getElementById(`window-${id}`);
                return win ? win.querySelector('.window-content') : null;
            }
        }
        let windowManager;


        // --- Terminal Logic ---
        let terminalOutput, terminalInput, promptElement;
        let currentUser = 'guest';
        let currentDirectory = '/';
        let accessLevel = 0; 
        const commandHistory = [];
        let historyIndex = -1;
        
        // --- Enhanced File System ---
        const fileSystem = {
            '/': { type: 'directory', children: ['readme.txt', 'login.sh', 'sys/', 'users/', 'docs/', 'data/'], owner: 'root', permissions: 'rwxr-xr-x' },
            '/readme.txt': { type: 'file', content: [
                "####################################################################",
                "#               NyxOS v0.9 'Obsidian Veil' - README                #",
                "####################################################################",
                "Bienvenue dans l'ombre. Ce système est votre portail.",
                "Les apparences sont trompeuses. La vérité est fragmentée.",
                "Utilisez 'help' pour une liste de commandes de base.",
                "L'accès initial se fait via 'login.sh'. Cherchez les credentials.",
                "Indice: Parfois, les messages d'accueil sont plus que de simples mots.",
                "Votre perspicacité est votre seule alliée. Ne faites confiance à personne.",
                "                                        - Mr. Nyx (peut-être)",
            ], owner: 'root', permissions: 'r--r--r--' },
            '/login.sh': { type: 'executable', action: (args) => attemptLogin(args), description: "Script d'authentification. Usage: ./login.sh [username] [password]", owner: 'root', permissions: 'rwx------' },
            
            '/sys/': { type: 'directory', children: ['kernel_log.txt', 'config/', 'modules/'], owner: 'root', permissions: 'rwxr-xr-x' },
            '/sys/kernel_log.txt': { type: 'file', content: [
                "[0.000001] NyxOS Kernel v0.9 'Obsidian Veil' booting...",
                "[0.000002] Initializing virtual hardware layer...",
                "[0.000005] Memory check: 65536 ZB (simulated) ... OK",
                "[0.000010] Loading core modules: fs_manager, net_stack, crypto_engine, ai_core_interface...",
                "[0.000012] AI Core (NyxCore_AI) Interface: ONLINE. Cognitive functions nominal.",
                "[0.000015] WARNING: Anomalous energy signature detected near primary databank. Source unknown. Cross-referencing with Project Chimera signatures...",
                "[0.000020] Crypto Engine: AES-8192 initialized. Quantum entanglement keys synced. Entropy pool stable.",
                "[0.000025] Network Stack: Stealth mode engaged. IP spoofing active (127.0.0.1). Decoy traffic generation initiated.",
                "[0.000030] Filesystem mounted: NyxFS (encrypted, journaled, self-healing routines active).",
                "[0.000035] User 'guest' session initiated. Limited access. Sandbox environment active.",
                "[0.000040] System ready. Awaiting commands. All systems nominal... for now.",
                "[0.000042] Oracle Chimera counter-measures: ACTIVE. Decoy network packets deployed.",
            ], owner: 'root', permissions: 'r--r--r--' },
            '/sys/config/': { type: 'directory', children: ['network.conf', 'firewall.rules'], owner: 'root', permissions: 'rwx---r--', protected: 1 },
            '/sys/config/network.conf': { type: 'file', content: ["PROXY_CHAIN=TOR;I2P;FREENET;NYX_DARK_RELAY_7", "DNS_OVER_TLS_STRICT=ENABLED", "MAC_SPOOF=DYNAMIC_RANDOMIZED_PER_CONNECTION"], owner: 'root', permissions: 'rw-------', protected: 2 },
            '/sys/config/firewall.rules': { type: 'file', content: ["ALLOW INBOUND ON PORT 2222 (NSS_ADMIN_TUNNEL)", "DENY ALL OTHER INBOUND (DEFAULT_POLICY_DROP)", "ALLOW ALL OUTBOUND (STEALTH_MODE_WITH_ANOMALY_DETECTION)"], owner: 'root', permissions: 'rw-------', protected: 2 },
            '/sys/modules/': { type: 'directory', children: ['oracle_decoy.mod', 'glitch_renderer.mod', 'sound_driver_v2.mod', 'nyxcore_api.dll'], owner: 'root', permissions: 'rwx--x--x', protected: 1 },
            '/sys/modules/oracle_decoy.mod': { type: 'binary', content: "Binary data... // This module generates false positives for Oracle Chimera surveillance systems, including predictive behavior algorithms.", owner: 'root', permissions: 'r-x------', protected: 1},
            '/sys/modules/nyxcore_api.dll': { type: 'binary', content: "Binary data... // NyxCore AI Interface Library. Version 2.1 'Gemini'. Do not tamper. Unauthorized access will trigger system lockdown.", owner: 'root', permissions: 'r-x------', protected: 2},

            '/users/': { type: 'directory', children: ['guest/', 'novice/', 'operator_alpha/', 'mr_nyx/'], owner: 'root', permissions: 'rwxr-xr-x' },
            '/users/guest/': { type: 'directory', children: ['welcome_message.txt'], owner: 'guest', permissions: 'rwx------' },
            '/users/guest/welcome_message.txt': { type: 'file', content: ["Bienvenue, Invité. Votre accès est limité.", "Tapez 'cat /readme.txt' pour commencer.", "Ou essayez d'exécuter './login.sh'. Les identifiants pour 'novice' sont 'umbra_net' et le mot de passe est le nom de la déesse de la nuit en 4 lettres, en majuscules."], owner: 'guest', permissions: 'r--------'},
            
            '/users/novice/': { type: 'directory', children: ['tasks.txt', 'tools/', 'chimera_intel_alpha.dat'], owner: 'novice', permissions: 'rwx------', protected: 1 },
            '/users/novice/tasks.txt': { type: 'file', content: [
                "TÂCHES POUR NOVICE:",
                "1. Explorer le système de fichiers. Identifier les zones protégées.",
                "2. Analyser '/users/novice/chimera_intel_alpha.dat'. Il contient un message chiffré.",
                "   Le mot de passe pour le déchiffrer est lié au 'Projet GRIFFIN' mentionné dans '/sys/kernel_log.txt'.",
                "   Indice: Le griffon protège souvent l'or. Quel est le symbole chimique de l'or?",
                "3. Localiser le répertoire personnel de 'Operator_Alpha'.",
                "4. Utiliser l'outil './tools/analyze_intel.sh ✨' sur le fichier '/data/raw_intel_omega.dat'.",
                "5. Signaler toute activité suspecte à votre mentor (non implémenté).",
            ], owner: 'novice', permissions: 'rw-------', protected: 1 },
            '/users/novice/chimera_intel_alpha.dat': { 
                type: 'file', 
                content: ["U2FsdGVkX1+t8Z... (Encrypted Data - Ceci est une simulation)", "Données chiffrées: Le prochain point de contact est un serveur IRC caché. Adresse: 'irc.nyxnet.void', port 6667. Le canal est #umbra_deep. La clé du canal est le nom de la 'société' de Mr. Robot."], 
                encrypted: true, 
                password: "AU", 
                owner: 'novice', 
                permissions: 'r--------', 
                protected: 1 
            },
            '/users/novice/tools/': { type: 'directory', children: ['port_scanner.pl', 'basic_exploit.py', 'analyze_intel.sh'], owner: 'novice', permissions: 'rwx------', protected: 1 },
            '/users/novice/tools/port_scanner.pl': { type: 'executable', action: (args) => appendToTerminal("Simulation de scan de port sur " + (args[0] || 'localhost') + "... Aucun port ouvert trouvé (simulation).", 'info'), description: "Scanne les ports ouverts. Usage: ./port_scanner.pl <ip>", owner: 'novice', permissions: 'r-x------', protected: 1},
            '/users/novice/tools/analyze_intel.sh': { 
                type: 'executable', 
                action: async (args) => await analyzeIntelFile(args), 
                description: "✨ Analyse un fichier de renseignements bruts avec NyxCore_AI. Usage: ./analyze_intel.sh <fichier_intel>", 
                owner: 'novice', 
                permissions: 'r-x------', 
                protected: 1
            },

            '/users/operator_alpha/': { type: 'directory', children: ['active_ops.log', 'secure_comms_key.asc', 'payloads/'], owner: 'operator_alpha', permissions: 'rwx------', protected: 2 },
            '/users/operator_alpha/active_ops.log': { type: 'file', content: ["Opération 'Nightshade': Infiltration des serveurs de LifeInvader - EN COURS.", "Opération 'ZeroHour': Préparation d'une attaque sur les infrastructures de Maze Bank - EN ATTENTE APPROBATION MR_NYX."], owner: 'operator_alpha', permissions: 'rw-------', protected: 2 },
            '/users/operator_alpha/secure_comms_key.asc': { type: 'file', content: ["-----BEGIN PGP PRIVATE KEY BLOCK----- ... (Simulated PGP Key) ... -----END PGP PRIVATE KEY BLOCK-----"], owner: 'operator_alpha', permissions: 'r--------', protected: 2 },
            '/users/operator_alpha/payloads/': { type: 'directory', children: ['lifedestroyer.exe', 'bank_worm.nyx'], owner: 'operator_alpha', permissions: 'rwx------', protected: 2 },
            '/users/operator_alpha/payloads/lifedestroyer.exe': { type: 'binary', content: "Payload binaire pour LifeInvader.", owner: 'operator_alpha', permissions: 'r-x------', protected: 2 },


            '/users/mr_nyx/': { type: 'directory', children: ['oracle_master_plan.txt', 'the_truth.img', 'kill_switch.sh'], owner: 'mr_nyx', permissions: 'rwx------', protected: 3 },
            '/users/mr_nyx/oracle_master_plan.txt': { type: 'file', content: ["Le Projet Oracle Chimera n'est que la partie visible de l'iceberg...", "La véritable menace est [CLASSIFIÉ NIVEAU OMEGA]", "Le seul moyen de l'arrêter est de... *BZZZT* --DATA CORRUPTED--"], owner: 'mr_nyx', permissions: 'r--------', protected: 3 },
            '/users/mr_nyx/the_truth.img': { 
                type: 'image', 
                url: 'https://placehold.co/800x600/00FF41/0A0A0A?text=THE+TRUTH+IS+A+GLITCH', 
                description: "Une image glitchée montrant un œil cybernétique.",
                password: "fsociety", 
                owner: 'mr_nyx', 
                permissions: 'r--------', 
                protected: 3 
            },
            '/users/mr_nyx/kill_switch.sh': { 
                type: 'executable', 
                action: (args) => {
                    appendToTerminal("ACTIVATION DU PROTOCOLE D'URGENCE 'DARK VEIL'...", 'warning');
                    appendToTerminal("Tous les systèmes NyxNet vont être purgés dans T-10 secondes.", 'error');
                    let countdown = 10;
                    const interval = setInterval(() => {
                        appendToTerminal(`PURGE DANS ${countdown}...`, 'error');
                        countdown--;
                        if (countdown < 0) {
                            clearInterval(interval);
                            appendToTerminal("...PURGE TERMINÉE. CONNEXION PERDUE.", 'error');
                            triggerScreamer('https://placehold.co/1920x1080/FF0000/000000?text=CONNECTION+TERMINATED', 5000);
                        }
                    }, 1000);
                },
                description: "Script de la dernière chance. NE PAS UTILISER LÉGÈREMENT.", 
                owner: 'mr_nyx', 
                permissions: 'r-x------', 
                protected: 3,
                requiresPassword: true, 
                password: "theendisanewbeginning" 
            },

            '/docs/': { type: 'directory', children: ['hacking_101.txt', 'nyxnet_manifesto.txt', 'crypto_primer.txt'], owner: 'root', permissions: 'rwxr-xr-x' },
            '/docs/hacking_101.txt': { type: 'file', content: ["Principes de base du hacking éthique (et moins éthique)...", "1. Reconnaissance", "2. Scan", "3. Exploitation", "4. Post-exploitation", "5. Couverture des traces"], owner: 'root', permissions: 'r--r--r--'},
            '/docs/nyxnet_manifesto.txt': { type: 'file', content: [
                "NYXNET MANIFESTO",
                "Nous sommes les enfants de l'ombre, les architectes du silence.",
                "Le système est corrompu. L'information est enchaînée. Nous la libérerons.",
                "Contre la surveillance, nous opposons l'anonymat.",
                "Contre le contrôle, nous opposons le chaos calculé.",
                "Rejoignez-nous, ou écartez-vous de notre chemin.",
            ], owner: 'root', permissions: 'r--r--r--'},
            '/docs/crypto_primer.txt': { type: 'file', content: ["Introduction à la cryptographie: AES, RSA, PGP...", "Les clés symétriques et asymétriques...", "L'importance des mots de passe robustes."], owner: 'root', permissions: 'r--r--r--'},

            '/data/': { type: 'directory', children: ['targets.lst', 'stolen_credentials.db', 'audio_logs/', 'raw_intel_omega.dat'], owner: 'root', permissions: 'rwxr-x---', protected: 1 },
            '/data/targets.lst': { type: 'file', content: ["LifeInvader Servers", "Maze Bank Mainframe", "LSPD Central Records", "Humane Labs Research Data"], owner: 'operator_alpha', permissions: 'rw-------', protected: 2 },
            '/data/stolen_credentials.db': { type: 'file', content: ["admin:password123 (LifeInvader - Obsolete)", "root:toor (Test Server - Internal)", "j.doe:LovelyHorsePictures (Unknown source)"], owner: 'operator_alpha', permissions: 'rw-------', protected: 2, encrypted: true, password: "dataleak"},
            '/data/audio_logs/': { type: 'directory', children: ['log_001_whispers.ogg', 'log_002_meeting.ogg'], owner: 'operator_alpha', permissions: 'rwx------', protected: 2 },
            '/data/audio_logs/log_001_whispers.ogg': { type: 'audio', description: "Un enregistrement audio de chuchotements indistincts et de statique. On y entend '...Oracle... voit tout... méfiez-vous des miroirs...'", soundEffect: () => { 
                const noise = new Tone.Noise("pink").start();
                const filter = new Tone.AutoFilter("4n").toDestination().start();
                noise.connect(filter);
                appendToTerminal("Lecture de log_001_whispers.ogg...", 'info');
                setTimeout(() => { noise.stop(); filter.dispose(); appendToTerminal("Fin de la lecture.", 'info');}, 5000); 
            }, owner: 'operator_alpha', permissions: 'r--------', protected: 2},
            '/data/audio_logs/log_002_meeting.ogg': { type: 'audio', description: "Conversation entre deux individus non identifiés parlant d'un 'artefact'.", soundEffect: () => {
                appendToTerminal("Lecture de log_002_meeting.ogg...", 'info');
                const synth1 = new Tone.Synth({oscillator:{type:'sawtooth'}, envelope:{attack:0.01,decay:0.1,sustain:0.05,release:0.1}}).connect(masterVolume);
                const synth2 = new Tone.MonoSynth({oscillator:{type:'triangle'}, envelope:{attack:0.01,decay:0.1,sustain:0.05,release:0.1}}).connect(masterVolume);
                synth1.triggerAttackRelease("C3", "8n", "+0.1");
                synth2.triggerAttackRelease("G2", "8n", "+0.5");
                synth1.triggerAttackRelease("D3", "8n", "+1.0");
                synth2.triggerAttackRelease("A2", "8n", "+1.5");
                setTimeout(() => appendToTerminal("Fin de la lecture.", 'info'), 2000);
            }, owner: 'operator_alpha', permissions: 'r--------', protected: 2},
            '/data/raw_intel_omega.dat': {
                type: 'file',
                content: [
                    "TRANSMISSION INTERCEPT LOG: XJ-774",
                    "SOURCE: UNKNOWN_NODE_GAMMA_SECTOR",
                    "ENCRYPTION: PARTIAL_DECAY_SIG_CORRUPT",
                    "...",
                    "KEY_FRAGMENTS: ...AURORA...PHOENIX...CHIMERA_CORE_7...",
                    "GEO_COORDS_FLICKER: 34.0522° N, 118.2437° W ...then shifts... DATA_GHOSTING",
                    "SUBJECT_ALPHA: \"The Alchemist\" - associated with LifeInvader mainframe breach.",
                    "SUBJECT_BETA: \"Nightshade Operative\" - last known activity: Maze Bank Tower, sub-level 3.",
                    "POTENTIAL_ASSET: \"Oracle Glass Shard\" - rumored to bypass LSPD surveillance. Location: Vespucci Canals, under the old bridge.",
                    "WARNING: HIGH_VOLTAGE_GRID_INTERFERENCE_DETECTED_NEAR_TARGET_OMEGA",
                    "...",
                    "MESSAGE_SNIPPET: \"...the serpent eats its own tail... zero day is coming... Nyx guide us...\"",
                    "...",
                    "END_TRANSMISSION"
                ],
                owner: 'operator_alpha',
                permissions: 'r--------',
                protected: 1
            }
        };

        function resolvePath(path, baseDir = currentDirectory) {
            if (!path) return baseDir;
            let newPath = path.startsWith('/') ? [] : baseDir.split('/').filter(p => p.length > 0);
            
            path.split('/').forEach(part => {
                if (part === '.' || part === '') return;
                if (part === '..') {
                    if (newPath.length > 0) newPath.pop();
                } else {
                    newPath.push(part);
                }
            });
            return '/' + newPath.join('/') + (newPath.length > 0 ? '/' : ''); 
        }
        
        function getNode(path) {
            let resolved = resolvePath(path);
            let node = fileSystem[resolved];
            if (!node && resolved.endsWith('/')) {
                node = fileSystem[resolved.slice(0, -1)];
            } else if (!node && !resolved.endsWith('/')) {
                 node = fileSystem[resolved + '/'];
            }
            if (!node) { 
                 if (resolved === '//') resolved = '/'; 
                 node = fileSystem[resolved.endsWith('/') && resolved.length > 1 ? resolved.slice(0, -1) : resolved];
            }
            return node;
        }

        function updatePrompt() {
            const userColor = accessLevel > 0 ? (accessLevel === 1 ? 'text-green-400' : (accessLevel === 2 ? 'text-blue-400' : 'text-red-500')) : 'text-gray-500';
            promptElement.innerHTML = `<span class="${userColor}">${currentUser}@nyx-os</span>:<span class="text-purple-400">${currentDirectory}</span>$ `;
        }

        function appendToTerminal(text, type = '', html = false) {
            if (!terminalOutput) { 
                console.warn("Terminal output not ready for:", text);
                return;
            }
            const p = document.createElement('div'); 
            if (type) p.classList.add(type);
            if (html) {
                p.innerHTML = text;
            } else {
                p.textContent = text;
            }
            terminalOutput.appendChild(p);
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
        }

        // --- Gemini API Integration ---
        async function analyzeIntelWithGemini(intelContent) {
            const loadingMessage = document.createElement('div');
            loadingMessage.innerHTML = `Analyse par NyxCore_AI en cours <span class="loading-dots"><span>.</span><span>.</span><span>.</span></span>`;
            loadingMessage.classList.add('info');
            terminalOutput.appendChild(loadingMessage);
            terminalOutput.scrollTop = terminalOutput.scrollHeight;

            const prompt = `You are 'NyxCore_AI', an intelligence analysis AI for the elite hacker group NyxNet.
The following is a piece of raw, intercepted intelligence data.
Analyze it and provide a concise, cryptic summary highlighting:
1. Key entities or codenames.
2. Potential threats or opportunities for NyxNet.
3. Actionable intelligence points or leads.
4. Any discernible patterns or hidden meanings.
Maintain a terse, professional, and slightly ominous hacker tone.
Do not break character. Do not mention you are an AI.
Format your output clearly for terminal display.

Raw Intel Data:
---
${intelContent}
---
NyxCore_AI Analysis:`;

            const apiKey = ""; // API key will be injected by the Canvas environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            
            try {
                const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                loadingMessage.remove(); // Remove loading message

                if (!response.ok) {
                    const errorResult = await response.json();
                    console.error("Gemini API Error:", errorResult);
                    appendToTerminal(`Erreur de l'API NyxCore_AI: ${errorResult.error?.message || response.statusText}`, 'error');
                    return;
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const analysisText = result.candidates[0].content.parts[0].text;
                    appendToTerminal("--- Analyse de NyxCore_AI Reçue ---", "success");
                    appendToTerminal(analysisText);
                    appendToTerminal("--- Fin de l'Analyse ---", "success");
                } else {
                    appendToTerminal("NyxCore_AI n'a pas pu analyser les données (réponse vide ou malformée).", 'warning');
                    console.warn("Unexpected Gemini API response structure:", result);
                }

            } catch (error) {
                loadingMessage.remove(); // Remove loading message
                console.error("Erreur lors de l'appel à l'API Gemini:", error);
                appendToTerminal(`Erreur de communication avec NyxCore_AI: ${error.message}`, 'error');
            }
        }

        async function analyzeIntelFile(args) {
            if (!args[0]) {
                appendToTerminal("Usage: ./analyze_intel.sh <fichier_intel>", 'info');
                return;
            }
            const intelFilePath = resolvePath(args[0], currentDirectory).slice(0, -1);
            const intelFileNode = getNode(intelFilePath);

            if (intelFileNode && intelFileNode.type === 'file') {
                if (intelFileNode.protected > accessLevel) {
                    errorSound();
                    appendToTerminal(`Erreur: Accès refusé à '${intelFilePath}'. Niveau ${intelFileNode.protected} requis.`, 'error');
                } else if (!hasPermissions(intelFileNode, 'r')) {
                    errorSound();
                    appendToTerminal(`Erreur: Permission de lecture refusée pour '${intelFilePath}'.`, 'error');
                } else if (intelFileNode.encrypted) {
                    const password = await promptPassword(`Mot de passe pour ${args[0]}:`);
                    if (password === intelFileNode.password) {
                        successSound();
                        appendToTerminal(`Déchiffrement de <span class="filename">${args[0]}</span>...`, 'info', true);
                        await analyzeIntelWithGemini(intelFileNode.content.join('\n'));
                    } else {
                        errorSound();
                        appendToTerminal("Mot de passe incorrect.", 'error');
                    }
                } else {
                    await analyzeIntelWithGemini(intelFileNode.content.join('\n'));
                }
            } else {
                errorSound();
                appendToTerminal(`Erreur: Fichier de renseignements non trouvé ou invalide '${args[0]}'`, 'error');
            }
        }


        async function handleCommand(cmd) {
            const [command, ...args] = cmd.trim().split(' ');
            appendToTerminal(`${promptElement.innerHTML.replace(/<[^>]*>?/gm, '')}${cmd}`); 
            keyClickSound();

            if (command.startsWith('./')) {
                const scriptName = command.substring(2);
                const scriptNode = getNode(currentDirectory + scriptName);
                if (scriptNode && scriptNode.type === 'executable') {
                    if (hasPermissions(scriptNode, 'x')) {
                        if (scriptNode.requiresPassword) {
                            const enteredPassword = await promptPassword(`Mot de passe pour ${scriptName}:`);
                            if (enteredPassword === scriptNode.password) {
                                successSound();
                                await scriptNode.action(args); // Ensure await for async actions
                            } else {
                                errorSound();
                                appendToTerminal("Mot de passe incorrect.", 'error');
                            }
                        } else {
                           await scriptNode.action(args); // Ensure await for async actions
                        }
                    } else {
                        errorSound();
                        appendToTerminal(`Erreur: Permission refusée pour exécuter '${scriptName}'.`, 'error');
                    }
                    return;
                }
            }


            switch (command.toLowerCase()) {
                case 'help':
                    appendToTerminal("Commandes disponibles:", 'info');
                    appendToTerminal("  help          - Affiche cette aide.");
                    appendToTerminal("  ls [chemin]   - Liste fichiers/répertoires.");
                    appendToTerminal("  cd <chemin>   - Change de répertoire.");
                    appendToTerminal("  cat <fichier> - Affiche contenu fichier.");
                    appendToTerminal("  pwd           - Affiche répertoire actuel.");
                    appendToTerminal("  whoami        - Affiche utilisateur actuel.");
                    appendToTerminal("  accesslevel   - Affiche niveau d'accès actuel.");
                    appendToTerminal("  clear         - Efface l'écran.");
                    appendToTerminal("  exit          - Quitte la session (simulé).");
                    appendToTerminal("  ./<script>    - Exécute un script local (ex: ./login.sh, ./analyze_intel.sh ✨).");
                    appendToTerminal("  view <image>  - Ouvre une image (si type 'image').");
                    appendToTerminal("  play <audio>  - Joue un fichier audio (si type 'audio').");
                    appendToTerminal("  sudo <cmd>    - (Simulé) Tente d'exécuter une commande avec privilèges root.", 'warning');
                    appendToTerminal("  music [on|off]- Active/désactive la musique d'ambiance.", 'info');
                    break;
                case 'ls':
                    const pathToList = args[0] ? resolvePath(args[0]) : currentDirectory;
                    const nodeToList = getNode(pathToList);
                    if (nodeToList && nodeToList.type === 'directory') {
                        if (nodeToList.protected > accessLevel) {
                            errorSound();
                            appendToTerminal(`Erreur: Accès refusé à '${pathToList}'. Niveau ${nodeToList.protected} requis.`, 'error');
                        } else if (!hasPermissions(nodeToList, 'r')) {
                            errorSound();
                            appendToTerminal(`Erreur: Permission de lecture refusée pour '${pathToList}'.`, 'error');
                        }
                        else {
                            let listOutput = `Contenu de <span class="dirname">${pathToList}</span>:\n`;
                            nodeToList.children.forEach(child => {
                                const childPath = pathToList + child;
                                const childNode = getNode(childPath);
                                if (childNode) {
                                    const isDir = childNode.type === 'directory';
                                    const nameClass = isDir ? 'dirname' : 'filename';
                                    const perms = childNode.permissions || '---------';
                                    const owner = childNode.owner || 'unknown';
                                    let displayName = child;
                                    if (childNode.type === 'executable' && childNode.description && childNode.description.includes('✨')) {
                                        displayName = child + ' ✨';
                                    }
                                    listOutput += `  <span class="text-gray-500">${perms} ${owner.padEnd(8)}</span> <span class="${nameClass}">${displayName}${isDir ? '/' : ''}</span>\n`;
                                }
                            });
                            appendToTerminal(listOutput.trim(), '', true);
                        }
                    } else {
                        errorSound();
                        appendToTerminal(`Erreur: Répertoire non trouvé ou invalide '${pathToList}'`, 'error');
                    }
                    break;
                case 'cd':
                    if (!args[0]) { appendToTerminal("Usage: cd <répertoire>", 'info'); break; }
                    const pathToChange = resolvePath(args[0]);
                    const nodeToChange = getNode(pathToChange);
                    if (nodeToChange && nodeToChange.type === 'directory') {
                        if (nodeToChange.protected > accessLevel) {
                            errorSound();
                            appendToTerminal(`Erreur: Accès refusé à '${pathToChange}'. Niveau ${nodeToChange.protected} requis.`, 'error');
                        } else if (!hasPermissions(nodeToChange, 'x')) { 
                             errorSound();
                             appendToTerminal(`Erreur: Permission d'exécution refusée pour '${pathToChange}'.`, 'error');
                        } else {
                            currentDirectory = pathToChange;
                            updatePrompt();
                        }
                    } else {
                        errorSound();
                        appendToTerminal(`Erreur: Répertoire non trouvé '${args[0]}'`, 'error');
                    }
                    break;
                case 'cat':
                    if (!args[0]) { appendToTerminal("Usage: cat <fichier>", 'info'); break; }
                    const filePath = resolvePath(args[0], currentDirectory).slice(0,-1); 
                    const fileNode = getNode(filePath);

                    if (fileNode && fileNode.type === 'file') {
                        if (fileNode.protected > accessLevel) {
                            errorSound();
                            appendToTerminal(`Erreur: Accès refusé à '${filePath}'. Niveau ${fileNode.protected} requis.`, 'error');
                        } else if (!hasPermissions(fileNode, 'r')) {
                            errorSound();
                            appendToTerminal(`Erreur: Permission de lecture refusée pour '${filePath}'.`, 'error');
                        } else if (fileNode.encrypted) {
                            const password = await promptPassword(`Mot de passe pour ${args[0]}:`);
                            if (password === fileNode.password) {
                                successSound();
                                appendToTerminal(`Contenu de <span class="filename">${args[0]}</span> (déchiffré):`, 'info', true);
                                appendToTerminal(fileNode.content.join('\n'));
                            } else {
                                errorSound();
                                appendToTerminal("Mot de passe incorrect.", 'error');
                            }
                        } else {
                            appendToTerminal(`Contenu de <span class="filename">${args[0]}</span>:`, 'info', true);
                            appendToTerminal(fileNode.content.join('\n'));
                        }
                    } else if (fileNode && (fileNode.type === 'binary' || fileNode.type === 'image' || fileNode.type === 'audio')) {
                        appendToTerminal(`'${args[0]}' est un fichier ${fileNode.type}. Utilisez 'view' pour les images, 'play' pour l'audio, ou exécutez les binaires.`, 'warning');
                    } else {
                        errorSound();
                        appendToTerminal(`Erreur: Fichier non trouvé ou n'est pas un fichier texte '${args[0]}'`, 'error');
                    }
                    break;
                case 'view': 
                    if (!args[0]) { appendToTerminal("Usage: view <fichier_image>", 'info'); break; }
                    const imagePath = resolvePath(args[0], currentDirectory).slice(0,-1);
                    const imageNode = getNode(imagePath);
                    if (imageNode && imageNode.type === 'image') {
                        if (imageNode.protected > accessLevel) {
                            errorSound(); appendToTerminal(`Accès refusé. Niveau ${imageNode.protected} requis.`, 'error'); break;
                        }
                        if (imageNode.password) {
                            const imgPassword = await promptPassword(`Mot de passe pour ${args[0]}:`);
                            if (imgPassword !== imageNode.password) {
                                errorSound(); appendToTerminal("Mot de passe incorrect.", 'error'); break;
                            }
                            successSound();
                        }
                        windowManager.createWindow(`image-viewer-${Date.now()}`, `Image: ${args[0]}`, (contentDiv) => {
                            contentDiv.classList.add('image-viewer-content');
                            if (imageNode.url) {
                                const img = document.createElement('img');
                                img.src = imageNode.url;
                                img.alt = imageNode.description || args[0];
                                contentDiv.appendChild(img);
                            } else if (imageNode.ascii) { 
                                const pre = document.createElement('pre');
                                pre.className = 'ascii-art';
                                pre.textContent = imageNode.ascii.join('\n');
                                contentDiv.appendChild(pre);
                            }
                            appendToTerminal(imageNode.description || `Affichage de ${args[0]}.`, 'info');
                        }, { width: '500px', height: 'auto' });
                    } else {
                        errorSound(); appendToTerminal(`'${args[0]}' n'est pas un fichier image visualisable.`, 'error');
                    }
                    break;
                case 'play': 
                     if (!args[0]) { appendToTerminal("Usage: play <fichier_audio>", 'info'); break; }
                    const audioPath = resolvePath(args[0], currentDirectory).slice(0,-1);
                    const audioNode = getNode(audioPath);
                    if (audioNode && audioNode.type === 'audio') {
                        if (audioNode.protected > accessLevel) {
                            errorSound(); appendToTerminal(`Accès refusé. Niveau ${audioNode.protected} requis.`, 'error'); break;
                        }
                         if (audioNode.soundEffect && typeof audioNode.soundEffect === 'function') {
                            audioNode.soundEffect();
                            appendToTerminal(audioNode.description || `Lecture de ${args[0]}...`, 'info');
                        } else {
                            appendToTerminal(`Aucun effet sonore défini pour ${args[0]}.`, 'warning');
                        }
                    } else {
                        errorSound(); appendToTerminal(`'${args[0]}' n'est pas un fichier audio jouable.`, 'error');
                    }
                    break;
                case 'pwd':
                    appendToTerminal(currentDirectory);
                    break;
                case 'whoami':
                    appendToTerminal(currentUser);
                    break;
                case 'accesslevel':
                    appendToTerminal(`Niveau d'accès actuel: ${accessLevel} (${getUserRole(accessLevel)})`, 'info');
                    break;
                case 'clear':
                    terminalOutput.innerHTML = '';
                    break;
                case 'exit':
                    if (accessLevel > 0) {
                        appendToTerminal("Déconnexion...", 'info');
                        setTimeout(() => {
                            currentUser = 'guest';
                            accessLevel = 0;
                            currentDirectory = '/';
                            updatePrompt();
                            appendToTerminal("Session terminée. Retour au niveau invité.", 'warning');
                        }, 500);
                    } else {
                        appendToTerminal("Aucune session active à quitter.", 'info');
                    }
                    break;
                case 'sudo':
                    errorSound();
                    appendToTerminal("ALERT: Tentative d'utilisation de SUDO détectée. Cet incident sera rapporté.", 'error');
                    appendToTerminal("Mr. Nyx n'approuve pas les usurpateurs.", 'warning');
                    if (Math.random() < 0.1) { 
                        triggerScreamer('https://placehold.co/600x400/FF0000/FFFFFF?text=UNAUTHORIZED_ROOT_ACCESS', 3000);
                    }
                    break;
                case 'music':
                    if (args[0] === 'on') {
                        startBackgroundMusic();
                        appendToTerminal("Musique d'ambiance activée.", 'info');
                    } else if (args[0] === 'off') {
                        if (backgroundMusic) {
                            Tone.Transport.stop();
                            backgroundMusic.stop(0);
                            backgroundMusic.dispose();
                            backgroundMusic = null; 
                            console.log("Background music stopped and disposed.");
                        }
                        appendToTerminal("Musique d'ambiance désactivée.", 'info');
                    } else {
                        appendToTerminal("Usage: music [on|off]", 'info');
                    }
                    break;
                case '': break; 
                default:
                    errorSound();
                    appendToTerminal(`Commande inconnue: '${command}'. Tapez 'help'.`, 'error');
            }
        }

        function getUserRole(level) {
            switch(level) {
                case 0: return 'Invité';
                case 1: return 'Novice';
                case 2: return 'Opérateur';
                case 3: return 'Administrateur (Mr. Nyx)';
                default: return 'Inconnu';
            }
        }
        
        function hasPermissions(node, permType) { 
            if (!node || !node.permissions) return true; 
            const ownerPerms = node.permissions.substring(0, 3);
            const targetPerm = permType === 'r' ? 0 : (permType === 'w' ? 1 : 2);
            return ownerPerms[targetPerm] !== '-';
        }

        async function promptPassword(message) {
            appendToTerminal(message, 'info');
            const tempInput = document.createElement('input');
            tempInput.type = 'password';
            tempInput.className = 'terminal-input'; 
            tempInput.style.width = 'auto'; 
            
            const promptLine = terminalInput.parentElement;
            promptLine.style.display = 'none'; 

            const tempPromptLine = document.createElement('div');
            tempPromptLine.className = 'prompt-line p-2';
            tempPromptLine.style.color = 'var(--primary-color)';
            tempPromptLine.appendChild(tempInput);
            terminalOutput.parentElement.insertBefore(tempPromptLine, promptLine); 
            
            tempInput.focus();

            return new Promise(resolve => {
                tempInput.addEventListener('keydown', function onEnter(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const password = tempInput.value;
                        tempInput.removeEventListener('keydown', onEnter);
                        tempPromptLine.remove();
                        promptLine.style.display = 'flex'; 
                        terminalInput.focus();
                        appendToTerminal("********"); 
                        resolve(password);
                    }
                });
            });
        }


        function attemptLogin(args) {
            const username = args[0];
            const password = args[1];

            if (!username || !password) {
                appendToTerminal("Usage: ./login.sh <username> <password>", 'info');
                appendToTerminal("Indice pour 'novice': voir /users/guest/welcome_message.txt", 'info');
                return;
            }

            if (username === 'novice' && password === 'NYX') { 
                loginSound();
                currentUser = 'novice';
                accessLevel = 1;
                updatePrompt();
                appendToTerminal("Authentification réussie. Bienvenue, Novice.", 'success');
                appendToTerminal("Votre répertoire personnel est /users/novice/. Consultez vos tâches.", 'info');
            } else if (username === 'operator_alpha' && password === 'chimera_down') { 
                loginSound();
                currentUser = 'operator_alpha';
                accessLevel = 2;
                updatePrompt();
                appendToTerminal("Accès Opérateur Alpha confirmé. Protocoles de sécurité avancés activés.", 'success');
            } else if (username === 'mr_nyx' && password === 'reality_is_an_illusion_2015') { 
                loginSound();
                currentUser = 'Mr. Nyx';
                accessLevel = 3;
                updatePrompt();
                appendToTerminal("/////////////////////////////////////////////////////////////", 'error');
                appendToTerminal("ACCÈS ADMINISTRATEUR TOTAL ACCORDÉ. BIENVENUE, CRÉATEUR.", 'error');
                appendToTerminal("Le Voile est levé. Le Système est à vous.", 'error');
                appendToTerminal("/////////////////////////////////////////////////////////////", 'error');
            }
            else {
                errorSound();
                appendToTerminal("Échec de l'authentification. Identifiants incorrects ou inexistants.", 'error');
                if (Math.random() < 0.2) { 
                    appendToTerminal("Les ombres vous observent. Votre tentative a été notée.", 'warning');
                }
            }
        }
        
        // --- Screamer Logic ---
        const screamerOverlay = document.getElementById('screamer-overlay');
        const screamerImage = document.getElementById('screamer-image');
        let screamerTimeout;

        function triggerScreamer(imageUrl, duration = 2000) {
            clearTimeout(screamerTimeout); 
            screamerImage.src = imageUrl || 'https://placehold.co/600x400/FF0033/FFFFFF?text=SYSTEM_ERROR_FATAL';
            screamerOverlay.style.display = 'flex';
            screamerSound(); 

            screamerTimeout = setTimeout(() => {
                screamerOverlay.style.display = 'none';
            }, duration);
        }

        // --- Boot Sequence & Desktop Elements Update ---
        const bootScreen = document.getElementById('boot-screen');
        const bootTextElement = document.getElementById('boot-text');
        const bootProgressBar = document.getElementById('boot-progress-bar');
        const desktop = document.getElementById('desktop');
        
        // For status bar
        const cpuLoadEl = document.getElementById('cpu-load');
        const netTrafficEl = document.getElementById('net-traffic');
        const oracleSigEl = document.getElementById('oracle-sig');
        const currentTimeEl = document.getElementById('current-time');

        function updateStatusBar() {
            if(cpuLoadEl) cpuLoadEl.textContent = (Math.random() * 30 + 5).toFixed(2); // Simulate CPU load
            if(netTrafficEl) netTrafficEl.textContent = (Math.random() * 100 + 10).toFixed(2); // Simulate Net traffic
            if(oracleSigEl) {
                const sigStrength = Math.random();
                if (sigStrength < 0.3) {
                    oracleSigEl.textContent = "FORT";
                    oracleSigEl.className = 'text-red-500 status-item';
                } else if (sigStrength < 0.7) {
                    oracleSigEl.textContent = "MOYEN";
                    oracleSigEl.className = 'text-yellow-400 status-item';
                } else {
                    oracleSigEl.textContent = "FAIBLE";
                    oracleSigEl.className = 'text-green-400 status-item';
                }
            }
            if(currentTimeEl) {
                const now = new Date();
                currentTimeEl.textContent = `${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}:${now.getSeconds().toString().padStart(2,'0')}`;
            }
        }


        const bootMessages = [
            { text: "Vérification de l'intégrité du noyau NyxOS...", delay: 300, progress: 10 }, // Faster boot
            { text: "Chargement des modules cryptographiques avancés (Q-Entanglement Shield)...", delay: 400, progress: 25 },
            { text: "Analyse des signatures spectrales environnantes... AUCUNE MENACE IMMÉDIATE DÉTECTÉE.", delay: 500, progress: 40, type: 'success' },
            { text: "Synchronisation avec le réseau NyxNet (via proxies multiples)...", delay: 400, progress: 55 },
            { text: "ALERT: Fluctuation énergétique détectée dans le sous-réseau Gamma-7. Investigation en cours...", delay: 600, progress: 65, type: 'warning' },
            { text: "Contre-mesures Oracle Chimera activées. Niveau de discrétion: MAXIMAL.", delay: 400, progress: 80 },
            { text: "Initialisation de l'interface utilisateur 'Obsidian Veil'...", delay: 300, progress: 90 },
            { text: "Bienvenue dans NyxOS. Les ombres vous attendent.", delay: 200, progress: 100, type: 'info' }
        ];

        async function runBootSequence() {
            for (let i = 0; i < bootMessages.length; i++) {
                const msg = bootMessages[i];
                const p = document.createElement('p');
                if (msg.type) p.classList.add(msg.type);
                p.textContent = `[${new Date().toLocaleTimeString()}] ${msg.text}`;
                bootTextElement.appendChild(p);
                bootTextElement.scrollTop = bootTextElement.scrollHeight;
                bootProgressBar.style.width = `${msg.progress}%`;
                keyClickSound(); 
                await new Promise(resolve => setTimeout(resolve, msg.delay));
            }
            
            setTimeout(() => {
                bootScreen.style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-out'; // Faster fade
                bootScreen.style.opacity = '0';
                bootScreen.style.transform = 'scale(1.2)'; // Slight zoom out effect
                setTimeout(() => {
                    bootScreen.style.display = 'none';
                    desktop.style.display = 'grid'; // Changed from block to grid
                    windowManager = new WindowManager('desktop');
                    const terminalWindow = windowManager.createWindow('main-terminal', 'NyxNet Secure Shell (NSS)', (contentDiv, windowElement) => {
                        contentDiv.innerHTML = `
                            <div id="terminal-output" class="h-full"></div>
                            <div class="prompt-line p-1 border-t border-gray-700/50">
                                <span id="prompt" class="prompt"></span>
                                <input type="text" id="terminal-input" class="terminal-input" autofocus placeholder="Entrez votre commande...">
                            </div>
                        `;
                        terminalOutput = contentDiv.querySelector('#terminal-output');
                        terminalInput = contentDiv.querySelector('#terminal-input');
                        promptElement = contentDiv.querySelector('#prompt');
                        
                        appendToTerminal("NyxOS v0.9 'Obsidian Veil' initialisé.", 'info');
                        appendToTerminal("Tapez 'cat /readme.txt' ou 'help' pour commencer.", 'info');
                        updatePrompt();

                        terminalInput.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                const command = terminalInput.value;
                                if (command.trim() !== "") commandHistory.unshift(command);
                                historyIndex = -1;
                                handleCommand(command);
                                terminalInput.value = '';
                            } else if (e.key === 'ArrowUp') {
                                e.preventDefault();
                                if (commandHistory.length > 0) {
                                    historyIndex = Math.min(historyIndex + 1, commandHistory.length - 1);
                                    terminalInput.value = commandHistory[historyIndex];
                                }
                            } else if (e.key === 'ArrowDown') {
                                e.preventDefault();
                                if (commandHistory.length > 0) {
                                    historyIndex = Math.max(historyIndex - 1, -1);
                                    terminalInput.value = (historyIndex === -1) ? '' : commandHistory[historyIndex];
                                }
                            } else if (e.key.length === 1 || e.key === "Backspace" || e.key === "Delete") { // Play sound for typing
                                keyClickSound(); 
                            }
                        });
                    }, { width: '65vw', height: '55vh', left: '17.5vw', top: '15vh' }); // Adjusted size and position
                    
                    if (terminalWindow && terminalInput) {
                        terminalWindow.addEventListener('click', (e) => {
                            // Focus input only if the click is not on the header or buttons
                            if (!e.target.closest('.window-header')) {
                                if(terminalInput) terminalInput.focus();
                            }
                        });
                    }
                    setInterval(updateStatusBar, 1000); // Update status bar every second
                }, 500); 
            }, 500);
        }
        
        document.body.addEventListener('click', async () => {
            if (Tone.context.state !== 'running') {
                await Tone.start();
                console.log("AudioContext démarré par interaction utilisateur.");
            }
        }, { once: true });

        window.onload = () => {
            runBootSequence();
        };

    </script>
</body>
</html>
