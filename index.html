<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NyxOS v3.2 - Exploits & Network</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&family=Roboto+Mono:wght@300;400&display=swap" rel="stylesheet">
    <style>
        :root {
            --font-primary: 'Roboto Mono', monospace;
            --font-display: 'Share Tech Mono', monospace;
            --font-glitch: 'VT323', monospace;

            --color-black: #010203;
            --color-deep-bg: #030609; 
            --color-dark-grey: #0A0F14;
            --color-medium-grey: #181C22;
            --color-light-grey: #2C313A;
            
            --color-green-bright: #00FF41;
            --color-green-medium: #00b32d;
            --color-green-dark: #007a1f;
            
            --color-cyan-bright: #0DFFFF;
            --color-cyan-medium: #0aa1a1;
            
            --color-purple-bright: #DA00FF;
            --color-red-error: #FF1A4D;
            --color-orange-warning: #FFA500; 


            --glow-primary: 0 0 4px var(--color-green-bright), 0 0 8px var(--color-green-medium), 0 0 12px var(--color-green-dark);
            --glow-secondary: 0 0 4px var(--color-cyan-bright), 0 0 8px var(--color-cyan-medium);
            --glow-error: 0 0 5px var(--color-red-error), 0 0 10px var(--color-red-error);

            /* POGBA: BACKGROUND_IMAGE_URL */
            /* Remplacez l'URL ci-dessous par le lien direct vers VOTRE image de fond pour le bureau NyxOS. */
            --desktop-background-image: url('https://placehold.co/1920x1080/010203/030609.png?text=NYX_DESKTOP_BACKGROUND');
        
            --color-green-medium-rgb-values: 0,179,45;
            --color-green-bright-rgb-values: 0,255,65;
            --color-light-grey-rgb-values: 44,49,58;
            --color-cyan-bright-rgb-values: 13,255,255;
            --color-black-rgb-values: 1,2,3;
            --color-green-dark-rgb-values: 0,122,31;
            --color-orange-warning-rgb-values: 255,165,0;
        }

        /* --- Animations Globales --- */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes subtleScanline { 0% { background-position-y: 0px; } 100% { background-position-y: 4px; } } 
        @keyframes textGlitchEffect {
          0%, 100% { text-shadow: var(--glow-primary); opacity: 1; transform: skewX(0deg); }
          50% { text-shadow: 0 0 5px var(--color-red-error), 0 0 10px var(--color-red-error); opacity: 0.8; transform: skewX(2deg) translateX(2px); }
        }
        @keyframes pulseGlowSoft {
            0%, 100% { box-shadow: 0 0 8px rgba(var(--color-green-bright-rgb), 0.2); } 
            50% { box-shadow: 0 0 16px rgba(var(--color-green-bright-rgb), 0.4); }
        }
        @keyframes new-message-pulse {
            0% { background-color: var(--color-purple-bright); box-shadow: 0 0 10px var(--color-purple-bright); }
            50% { background-color: rgba(var(--color-purple-bright), 0.7); box-shadow: 0 0 20px var(--color-purple-bright); }
            100% { background-color: var(--color-purple-bright); box-shadow: 0 0 10px var(--color-purple-bright); }
        }
        @keyframes loading-spinner {
            to {transform: rotate(360deg);}
        }
        .spinner {
            display: inline-block;
            width: 1em; height: 1em;
            border: 2px solid rgba(var(--color-cyan-bright-rgb), 0.3);
            border-radius: 50%;
            border-top-color: var(--color-cyan-bright);
            animation: loading-spinner 0.6s linear infinite;
            margin-right: 5px;
            vertical-align: middle;
        }


        /* --- Initialisation et Fond --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; width: 100%; overflow: hidden; }

        body {
            font-family: var(--font-primary);
            background-color: var(--color-deep-bg);
            background-image: 
                linear-gradient(rgba(var(--color-green-dark), 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(var(--color-green-dark), 0.03) 1px, transparent 1px),
                var(--desktop-background-image);
            background-size: 20px 20px, 20px 20px, cover;
            background-position: center;
            background-attachment: fixed;
            color: var(--color-green-bright);
            animation: fadeIn 1.2s ease-out;
            position: relative;
        }

        #matrix-rain-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none; opacity: 0.4; 
        }

        /* --- Structure du Bureau NyxOS --- */
        #nyx-desktop {
            position: relative; width: 100%; height: 100%;
            display: flex; 
            flex-direction: column;
            z-index: 2;
            box-shadow: inset 0 0 200px rgba(0,0,0,0.8);
        }
        
        #nyx-desktop::before { /* Scanlines */
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(0,0,0,0) 50%, rgba(0,0,0,0.1) 50%);
            background-size: 100% 3px; 
            animation: subtleScanline 0.15s linear infinite;
            pointer-events: none; z-index: 3; opacity: 0.15;
        }

        /* --- Header NyxOS --- */
        #nyx-header {
            background: linear-gradient(to bottom, rgba(var(--color-dark-grey), 0.9), rgba(var(--color-black), 0.8));
            border-bottom: 1px solid var(--color-green-medium);
            padding: 0 20px; height: 45px; 
            display: flex; align-items: center; justify-content: space-between;
            font-family: var(--font-display); z-index: 10; backdrop-filter: blur(8px);
            box-shadow: 0 2px 15px rgba(0,0,0,0.5);
        }
        #nyx-logo { font-size: 1.7em; text-shadow: var(--glow-primary); display: flex; align-items: center; cursor: default;}
        #nyx-clock { font-size: 1em; color: var(--color-cyan-bright); text-shadow: var(--glow-secondary); }

        /* --- Zone Principale des Applications --- */
        #main-app-area { 
            flex-grow: 1; 
            position: relative; overflow: hidden; padding: 20px; z-index: 5; 
        }

        /* --- Footer NyxOS --- */
        #nyx-footer {
            background: linear-gradient(to top, rgba(var(--color-dark-grey), 0.9), rgba(var(--color-black), 0.8));
            border-top: 1px solid var(--color-green-medium);
            padding: 0 20px; height: 30px; 
            display: flex; align-items: center; justify-content: space-between;
            font-size: 0.8em; z-index: 10; backdrop-filter: blur(8px);
            box-shadow: 0 -2px 15px rgba(0,0,0,0.5);
        }
        #user-status, #system-status { color: var(--color-cyan-bright); opacity: 0.7; }
        #nyx-comms-status-indicator {
            width: 10px; height: 10px; background-color: var(--color-light-grey);
            border-radius: 50%; margin-left: 10px; display: inline-block;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        #nyx-comms-status-indicator.new-message {
            animation: new-message-pulse 1.5s infinite;
        }


        /* --- Fenêtres des Applications --- */
        .app-window {
            position: absolute; 
            background-color: rgba(var(--color-medium-grey), 0.94);
            border: 1px solid var(--color-green-dark);
            border-radius: 3px; 
            box-shadow: 0 5px 25px rgba(0,0,0,0.7), inset 0 0 0 1px rgba(var(--color-green-bright-rgb),0.1); 
            display: flex; flex-direction: column;
            min-width: 350px; min-height: 250px;
            backdrop-filter: blur(12px) brightness(0.75);
            resize: both; overflow: hidden; 
            animation: fadeIn 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); 
        }
        .app-window.active {
            border-color: var(--color-green-bright);
            box-shadow: 0 8px 35px rgba(var(--color-green-bright-rgb), 0.4), inset 0 0 0 1px var(--color-green-bright); 
        }
        .window-header {
            background: linear-gradient(to bottom, var(--color-green-dark), rgba(var(--color-green-dark), 0.7)); 
            padding: 8px 12px; cursor: move;
            border-bottom: 1px solid var(--color-green-medium);
            display: flex; justify-content: space-between; align-items: center;
            font-family: var(--font-display);
        }
        .window-title { color: var(--color-green-bright); text-shadow: var(--glow-primary); font-size: 1.05em; }
        .window-buttons span {
            display: inline-block; width: 10px; height: 10px;
            border-radius: 50%; 
            margin-left: 5px; cursor: pointer;
            background-color: var(--color-light-grey); opacity: 0.8;
            transition: all 0.2s;
        }
        .window-buttons span.close-btn { background-color: var(--color-red-error); }
        .window-buttons span:hover { opacity: 1; transform: scale(1.1); filter: brightness(1.2); }

        .window-content {
            flex-grow: 1; padding: 15px; overflow: auto; 
            background-image: linear-gradient(rgba(var(--color-green-bright-rgb),0.01) 1px, transparent 1px); 
            background-size: 100% 3px; 
        }
        .window-content::-webkit-scrollbar { width: 8px; }
        .window-content::-webkit-scrollbar-track { background: rgba(var(--color-black-rgb),0.5); }
        .window-content::-webkit-scrollbar-thumb { background-color: var(--color-green-dark); }
        .window-content::-webkit-scrollbar-thumb:hover { background-color: var(--color-green-medium); }

        /* --- Terminal Spécifique --- */
        #terminal-output {
            white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;
            height: calc(100% - 32px); line-height: 1.6; font-size: 0.9em;
            text-shadow: 0 0 1px rgba(var(--color-green-bright-rgb), 0.3); 
        }
        .prompt-line { display: flex; margin-top: 6px; height: 26px; }
        .prompt { margin-right: 10px; font-family: var(--font-display); text-shadow: var(--glow-primary); font-size: 1.05em;}
        .terminal-input {
            background: transparent; border: none; color: var(--color-green-bright);
            flex-grow: 1; outline: none; font-family: inherit; font-size: 1.05em;
            caret-color: var(--color-purple-bright);
        }

        /* --- Echo Player (Lecteur Vidéo) --- */
        .echo-player-video { 
            width: 100%; height: auto; max-height: calc(100% - 60px); 
            background-color: #000;
            border: 1px solid var(--color-green-dark);
            margin-bottom: 10px;
        }
        .echo-player-controls { text-align: center; padding-top: 5px;}
        .echo-player-controls button {
            background-color: var(--color-green-dark); color: var(--color-green-bright);
            border: 1px solid var(--color-green-medium); padding: 6px 12px;
            font-family: var(--font-display); cursor: pointer; margin: 0 5px;
            border-radius: 2px; transition: background-color 0.2s;
        }
        .echo-player-controls button:hover { background-color: var(--color-green-medium); }

        /* --- Cognito Decryptor --- */
        .cognito-decryptor-input {
            width: 100%; padding: 10px; margin-bottom: 12px;
            background-color: rgba(var(--color-black-rgb), 0.6); 
            border: 1px solid var(--color-green-medium);
            color: var(--color-green-bright); font-family: var(--font-primary);
            border-radius: 2px; font-size: 1em;
        }
        .cognito-decryptor-button {
            background-color: var(--color-purple-bright); color: var(--color-black);
            border: none; padding: 10px 18px; font-family: var(--font-display);
            cursor: pointer; border-radius: 2px; transition: filter 0.2s; font-size: 1em;
        }
        .cognito-decryptor-button:hover { filter: brightness(1.2) saturate(1.2); }

        /* --- NyxComms (Messagerie) --- */
        .nyx-comms-container { display: flex; height: 100%; gap: 10px; }
        .message-list-panel { width: 35%; border-right: 1px solid var(--color-green-dark); overflow-y: auto; padding-right: 10px;}
        .message-view-panel { flex-grow: 1; overflow-y: auto; padding-left: 10px; }
        .message-item {
            padding: 8px 5px; border-bottom: 1px solid rgba(var(--color-green-dark-rgb), 0.5);
            cursor: pointer; transition: background-color 0.2s;
        }
        .message-item.unread { font-weight: bold; color: var(--color-green-bright); text-shadow: 0 0 2px var(--color-green-bright);}
        .message-item.read { font-weight: normal; color: var(--color-light-grey); opacity: 0.7;}
        .message-item:hover, .message-item.selected { background-color: rgba(var(--color-green-medium-rgb), 0.2); }
        .message-sender { font-weight: bold; color: var(--color-cyan-bright); font-size: 0.9em; }
        .message-subject { font-size: 0.85em; opacity: 0.9; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .message-timestamp { font-size: 0.7em; color: var(--color-light-grey); display: block; margin-top: 2px;}
        .message-body { white-space: pre-wrap; line-height: 1.5; font-size: 0.9em; }
        .message-body h4 { font-family: var(--font-display); color: var(--color-cyan-bright); margin-bottom: 8px; font-size: 1.1em; border-bottom: 1px dashed var(--color-cyan-medium); padding-bottom: 4px;}


        /* Classes de texte communes */
        .error { color: var(--color-red-error); animation: textGlitchEffect 0.3s; }
        .info { color: var(--color-cyan-bright); }
        .success { color: var(--color-green-bright); }
        .warning { color: var(--color-warning-color); }
        
        /* Boot Screen */
        #boot-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; color: var(--color-green-bright); z-index: 10000; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: var(--font-pixel); font-size: 1.5em; }
        #boot-text { margin-top: 20px; font-size: 0.8em; line-height: 1.4; }
        #boot-progress-bar-container { width: 70%; max-width: 500px; height: 22px; border: 1px solid var(--color-green-medium); margin-top: 15px; padding: 2px; background: rgba(var(--color-green-dark-rgb),0.3); }
        #boot-progress-bar { width: 0%; height: 100%; background: var(--color-green-bright); transition: width 0.15s linear; box-shadow: 0 0 8px var(--color-green-bright); }
        .nyx-logo-boot { font-family: var(--font-display); font-size: 3em; text-shadow: var(--glow-primary); margin-bottom: 10px; }

    </style>
</head>
<body>
    <canvas id="matrix-rain-canvas"></canvas>
    <div id="nyx-desktop" style="display:none;">
        <header id="nyx-header">
            <div id="nyx-logo">NyxOS</div>
            <div id="nyx-clock">--:--:--</div>
        </header>
        <main id="main-app-area">
            </main>
        <footer id="nyx-footer">
            <div id="user-status">USER: guest</div>
            <div id="system-status">SYSTEM: ONLINE <span id="nyx-comms-status-indicator"></span></div>
        </footer>
    </div>

    <div id="boot-screen">
        <div class="nyx-logo-boot">NYX OS</div>
        <pre id="boot-text-ascii" style="font-family: var(--font-pixel); font-size:0.6em; text-align:center; margin-bottom: 10px; color: var(--color-green-medium)">
        INITIALIZING CORE SYSTEMS...
        QUANTUM ENTANGLEMENT MATRIX... SYNCED
        NEURAL NETWORK INTERFACE... STANDBY
        ORACLE ECHO HANDLER... LOADING
        </pre>
        <div id="boot-text"></div>
        <div id="boot-progress-bar-container"><div id="boot-progress-bar"></div></div>
    </div>

    <script>
        // --- Configuration Globale ---
        /* POGBA: CUSTOM_MUSIC_URL */
        const customMusicUrl = ""; 

        window.onload = () => {
            // --- Script-scoped variables ---
            let terminalOutput, terminalInput, promptElement;
            let currentUser = 'guest';
            let currentDirectory = '/'; 
            let accessLevel = 0;
            const commandHistory = []; 
            let historyIndex = -1;   
            let currentEcho = null; 
            
            // --- Initialisation du Canvas Matrix Rain ---
            const canvas = document.getElementById('matrix-rain-canvas');
            const ctx = canvas.getContext('2d');
            let matrixInterval;

            function setupMatrix() { 
                if (!canvas || !ctx) return;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                const alphabet = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッンABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 partícula';
                const fontSize = 12;
                const columns = Math.floor(canvas.width / fontSize);
                const rainDrops = Array(columns).fill(1).map(() => Math.random() * canvas.height); 

                function drawMatrix() {
                    ctx.fillStyle = 'rgba(1, 2, 3, 0.03)'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'rgba(0, 255, 65, 0.6)'; 
                    ctx.font = fontSize + 'px monospace';
                    rainDrops.forEach((y, ind) => {
                        const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
                        const x = ind * fontSize;
                        ctx.fillText(text, x, y);
                        if (y > canvas.height && Math.random() > 0.99) { 
                            rainDrops[ind] = 0;
                        } else {
                            rainDrops[ind] = y + fontSize;
                        }
                    });
                }
                if (matrixInterval) clearInterval(matrixInterval);
                matrixInterval = setInterval(drawMatrix, 70); 
            }
            if (canvas) { setupMatrix(); window.addEventListener('resize', setupMatrix); }

            // --- Configuration Audio (Tone.js) ---
            let masterVolume = new Tone.Volume(-20).toDestination();
            const keyClickSound = () => new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, oscillator: { type: "square4" }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.05 }, volume: -28 }).connect(masterVolume).triggerAttackRelease("C1", "64n");
            const errorSound = () => new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0 }, volume: -15 }).connect(masterVolume).triggerAttackRelease("8n");
            const successSound = () => new Tone.PluckSynth({ attackNoise: 0.5, dampening: 6000, resonance: 0.8, volume: -15 }).connect(masterVolume).triggerAttackRelease("G4", "16n");
            let backgroundMusicPlayer;

            function startBackgroundMusic() {
                if (backgroundMusicPlayer && backgroundMusicPlayer.state === "started") return;
                if (!customMusicUrl) {
                    if(terminalOutput) appendToTerminal("Aucune URL de musique personnalisée définie.", "warning");
                    return;
                }
                backgroundMusicPlayer = new Tone.Player({ url: customMusicUrl, loop: true, autostart: false, volume: -18 }).toDestination(); 
                Tone.loaded().then(() => {
                    backgroundMusicPlayer.start();
                    if(terminalOutput) appendToTerminal("Musique personnalisée démarrée.", "success");
                }).catch(err => {
                    if(terminalOutput) appendToTerminal("Erreur chargement musique: " + err.message, "error");
                });
            }
            function stopBackgroundMusic() {
                if (backgroundMusicPlayer) {
                    backgroundMusicPlayer.stop().dispose();
                    backgroundMusicPlayer = null;
                    if(terminalOutput) appendToTerminal("Musique arrêtée.", "info");
                }
            }

            // --- DOM Elements ---
            const bootScreenEl = document.getElementById('boot-screen');
            const desktopEl = document.getElementById('nyx-desktop');
            const bootTextEl = document.getElementById('boot-text');
            const bootProgressBarEl = document.getElementById('boot-progress-bar');
            const nyxClockEl = document.getElementById('nyx-clock');
            const userStatusEl = document.getElementById('user-status');
            const systemStatusEl = document.getElementById('system-status');
            const commsIndicatorEl = document.getElementById('nyx-comms-status-indicator');
            
            // --- Helper pour CSS Variables dans Canvas ---
            function getCssVariableValue(variableName) {
                return getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
            }
            function getCssVariableRGBValues(variableName) { 
                return getCssVariableValue(variableName); 
            }


            // --- Window Manager ---
            class WindowManager {
                constructor(appAreaId) {
                    this.appArea = document.getElementById(appAreaId);
                    this.windows = []; this.zIndexCounter = 100; this.activeWindow = null;
                }
                createWindow(id, title, contentGenerator, options = {}) {
                    const win = document.createElement('div');
                    win.id = `window-${id}`; win.className = 'app-window';
                    win.style.width = options.width || '550px'; 
                    win.style.height = options.height || '400px';
                    const areaRect = this.appArea.getBoundingClientRect();
                    const defaultLeft = (areaRect.width - parseInt(win.style.width)) / 2;
                    const defaultTop = (areaRect.height - parseInt(win.style.height)) / 3;
                    win.style.left = options.left || `${defaultLeft + (Math.random()*50-25)}px`;
                    win.style.top = options.top || `${defaultTop + (Math.random()*50-25)}px`;
                    win.style.zIndex = this.zIndexCounter++;
                    const header = document.createElement('div'); header.className = 'window-header';
                    header.innerHTML = `<span class="window-title">${title}</span><div class="window-buttons"><span class="close-btn" title="Fermer"></span></div>`;
                    const content = document.createElement('div'); content.className = 'window-content';
                    if (typeof contentGenerator === 'string') content.innerHTML = contentGenerator;
                    else contentGenerator(content, win);
                    win.appendChild(header); win.appendChild(content);
                    this.appArea.appendChild(win); this.windows.push(win); this.setActive(win);
                    this.makeDraggable(win, header);
                    header.querySelector('.close-btn').addEventListener('click', (e) => { e.stopPropagation(); this.closeWindow(win.id); });
                    win.addEventListener('mousedown', () => this.setActive(win));
                    return win;
                }
                setActive(win) { this.windows.forEach(w => w.classList.remove('active')); win.classList.add('active'); win.style.zIndex = this.zIndexCounter++; this.activeWindow = win;}
                closeWindow(windowId) {
                    const win = document.getElementById(windowId);
                    if (win) {
                        win.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
                        win.style.opacity = '0'; win.style.transform = 'scale(0.95)';
                        setTimeout(() => {
                            win.remove();
                            this.windows = this.windows.filter(w => w.id !== windowId);
                            if (this.activeWindow === win) this.activeWindow = null;
                        }, 200);
                    }
                }
                makeDraggable(element, handle) {
                     let offsetX, offsetY, isDragging = false;
                     const mainAppArea = this.appArea; 

                    handle.onmousedown = (e) => {
                        if (e.target.closest('.window-buttons')) return;
                        isDragging = true;
                        offsetX = e.clientX - element.offsetLeft;
                        offsetY = e.clientY - element.offsetTop;
                        this.setActive(element);
                        document.body.style.cursor = 'move';
                        e.preventDefault();
                    };
                    document.onmousemove = (e) => {
                        if (!isDragging) return;
                        let newX = e.clientX - offsetX;
                        let newY = e.clientY - offsetY;
                        
                        newX = Math.max(0, Math.min(newX, mainAppArea.offsetWidth - element.offsetWidth));
                        newY = Math.max(0, Math.min(newY, mainAppArea.offsetHeight - element.offsetHeight));

                        element.style.left = newX + 'px';
                        element.style.top = newY + 'px';
                    };
                    document.onmouseup = () => {
                        if (isDragging) { isDragging = false; document.body.style.cursor = 'default';}
                    };
                }
            }
            let windowManager = new WindowManager('main-app-area');

            // --- NyxMapper Logic ---
            const networkNodes = {
                'nyx_mainframe': { x: 150, y: 100, label: 'Nyx Mainframe', status: 'Online', connections: ['corp_firewall'], info: "Serveur central de NyxNet. Hautement sécurisé.", ip: "10.0.1.1", services: ["NSS (Port 2222)", "Echo Sync"], vulnerabilities: ["Aucune connue"], locked: false },
                'corp_firewall': { x: 350, y: 100, label: 'Corp Firewall XG-7', status: 'Active', connections: ['data_archive_alpha'], info: "Pare-feu de CorpX.", ip: "192.168.10.1", services: ["HTTP (Port 80)", "HTTPS (Port 443)", "HTTP-ALT (Port 8080)"], vulnerabilities: ["Port 8080 (HTTP Alt.) ouvert - Potentiel pour injection de commandes.", "Firmware v2.1.3 (Obsolète) - Vulnérabilité connue: CVE-2077-001"], locked: false },
                'data_archive_alpha': { x: 350, y: 250, label: 'Data Archive α', status: 'Verrouillé', connections: [], info: "Contient des données financières de CorpX. Chiffré AES-256.", ip: "10.10.5.12", services: ["Unknown"], vulnerabilities: ["Accès physique requis pour exploit direct", "Protocole d'authentification faible (default_password?)"], locked: true }, 
                'hidden_relay_zeta': { x: 150, y: 250, label: 'Relais Zeta', status: 'Offline', connections: [], info: "Ancien relais. Actuellement hors-service.", ip: "172.16.33.7", services: ["N/A"], vulnerabilities: ["Inconnues (Système hors-ligne)"], locked: true } 
            };
            let hoveredNodeKey = null;

            function drawNyxMapper(canvasElement) {
                if (!canvasElement) return;
                const mapCtx = canvasElement.getContext('2d');
                canvasElement.width = canvasElement.offsetWidth; 
                canvasElement.height = canvasElement.offsetHeight;

                mapCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                mapCtx.font = `10px ${getCssVariableValue('--font-display')}`;
                mapCtx.textAlign = 'center';

                mapCtx.strokeStyle = `rgba(${getCssVariableRGBValues('--color-green-medium-rgb-values')}, 0.3)`;
                mapCtx.lineWidth = 1; 
                Object.values(networkNodes).forEach(node => {
                    if (node.locked) return; 
                    node.connections.forEach(connId => {
                        if (networkNodes[connId] && !networkNodes[connId].locked) {
                            mapCtx.beginPath();
                            mapCtx.moveTo(node.x, node.y);
                            mapCtx.lineTo(networkNodes[connId].x, networkNodes[connId].y);
                            mapCtx.stroke();
                        }
                    });
                });

                Object.entries(networkNodes).forEach(([key, node]) => {
                    const isHovered = key === hoveredNodeKey;
                    mapCtx.beginPath();
                    mapCtx.arc(node.x, node.y, isHovered ? 22 : 20, 0, Math.PI * 2); 
                    
                    if (node.locked) {
                        mapCtx.fillStyle = `rgba(${getCssVariableRGBValues('--color-orange-warning-rgb-values')}, ${isHovered ? 0.8 : 0.6})`;
                        mapCtx.strokeStyle = getCssVariableValue('--color-orange-warning');
                    } else {
                        mapCtx.fillStyle = node.status === 'Online' || node.status === 'Active' ? 
                                         `rgba(${getCssVariableRGBValues('--color-green-bright-rgb-values')}, ${isHovered ? 0.95 : 0.75})` : 
                                         `rgba(${getCssVariableRGBValues('--color-light-grey-rgb-values')}, ${isHovered ? 0.75 : 0.55})`;
                        mapCtx.strokeStyle = node.status === 'Online' || node.status === 'Active' ? 
                                           getCssVariableValue('--color-green-bright') : 
                                           getCssVariableValue('--color-light-grey');
                    }
                    mapCtx.fill();
                    mapCtx.lineWidth = isHovered ? 2.5 : 1.5;
                    mapCtx.stroke();
                    
                    mapCtx.fillStyle = getCssVariableValue('--color-black'); 
                    mapCtx.fillText(node.locked ? "???" : node.label.substring(0,3).toUpperCase(), node.x, node.y + 3); 
                    
                    mapCtx.fillStyle = node.locked ? getCssVariableValue('--color-orange-warning') : getCssVariableValue('--color-cyan-bright'); 
                    mapCtx.fillText(node.locked ? "NŒUD VERROUILLÉ" : node.label, node.x, node.y + 35); 
                });
            }
            
            function getNyxMapperNodeAtPos(canvasElement, x, y) {
                if (!canvasElement) return null;
                const rect = canvasElement.getBoundingClientRect();
                const canvasX = x - rect.left;
                const canvasY = y - rect.top;
                for (const [key, node] of Object.entries(networkNodes)) {
                    const distance = Math.sqrt(Math.pow(canvasX - node.x, 2) + Math.pow(canvasY - node.y, 2));
                    if (distance < (hoveredNodeKey === key ? 28: 25) ) { 
                        return key;
                    }
                }
                return null;
            }


            // --- Système de Fichiers & Logique Terminal ---
            const fileSystem = {
                '/': { type: 'directory', children: ['readme.txt', 'login.sh', 'apps/', 'echo_fragments/', 'tools/'] },
                '/readme.txt': { type: 'file', content: ["NyxOS v3.0 'Oracle Echoes'", "Système de NyxNet pour l'analyse des Échos de l'Oracle.", "Utilisez './login.sh' pour vous connecter.", "Commandes: ls, cd, cat, help, apps, open <fichier.echo>"] },
                '/login.sh': { type: 'executable', action: (args) => attemptLogin(args) },
                '/apps/': {type: 'directory', children: ['NyxMapper.app', 'NyxComms.app', 'EchoPlayer.app', 'CognitoDecryptor.app']} ,
                '/apps/NyxMapper.app': {type: 'executable', action: () => {
                    windowManager.createWindow('nyx-mapper', 'NyxMapper v0.3', (contentDiv) => {
                        const canvasEl = document.createElement('canvas');
                        canvasEl.id = 'nyx-mapper-canvas';
                        contentDiv.appendChild(canvasEl);
                        
                        const observer = new ResizeObserver(() => {
                             if (canvasEl.offsetWidth > 0 && canvasEl.offsetHeight > 0) {
                                drawNyxMapper(canvasEl);
                                observer.unobserve(canvasEl); 
                             }
                        });
                        observer.observe(canvasEl);

                        canvasEl.addEventListener('mousemove', (e) => {
                            const key = getNyxMapperNodeAtPos(canvasEl, e.clientX, e.clientY);
                            if (key !== hoveredNodeKey) {
                                hoveredNodeKey = key;
                                drawNyxMapper(canvasEl); 
                                canvasEl.style.cursor = key ? 'pointer' : 'default';
                            }
                        });
                        canvasEl.addEventListener('click', (e) => {
                            const key = getNyxMapperNodeAtPos(canvasEl, e.clientX, e.clientY);
                            if (key) {
                                const node = networkNodes[key];
                                const tempInfoDiv = document.createElement('div'); 
                                tempInfoDiv.innerHTML = `<p class="info" style="text-align:center; padding: 20px;"><span class="spinner"></span> Sondage du nœud ${node.label}...</p>`;
                                const infoWindow = windowManager.createWindow(`node-info-temp-${key}`, `Sondage: ${node.label}`, 
                                    (contentDiv) => { contentDiv.appendChild(tempInfoDiv); }, 
                                    { width: '380px', height: '120px' }
                                );

                                setTimeout(() => {
                                    windowManager.closeWindow(infoWindow.id); 
                                    if (node.locked) {
                                        windowManager.createWindow(`node-info-${key}`, `Info: ${node.label}`, 
                                            `<div style="padding:15px; font-size:0.9em; text-align:center;">
                                                <p class="warning">ACCÈS VERROUILLÉ</p>
                                                <p style="margin-top:10px;">Des informations supplémentaires ou un outil spécifique sont requis.</p>
                                            </div>`, 
                                            { width: '350px', height: '150px' }
                                        );
                                        return;
                                    }
                                    let vulnerabilitiesHTML = node.vulnerabilities.map(v => `<li>${v}</li>`).join('');
                                    let servicesHTML = node.services.map(s => `<li>${s}</li>`).join('');

                                    windowManager.createWindow(`node-info-${key}`, `Info: ${node.label}`, 
                                        (contentDiv) => { 
                                            contentDiv.innerHTML = `<div style="padding:10px; font-size:0.85em; line-height:1.4;">
                                                <p><strong>Adresse IP:</strong> <span class="info">${node.ip || "N/A"}</span></p>
                                                <p><strong>Statut:</strong> <span class="${node.status === 'Online' || node.status === 'Active' ? 'text-green-bright' : 'text-red-error'}">${node.status}</span></p>
                                                <p><strong>Description:</strong> ${node.info || "Aucune information supplémentaire."}</p>
                                                <h4 style="margin-top:10px; color:var(--color-cyan-medium); border-bottom:1px dashed var(--color-cyan-medium); padding-bottom:3px;">Services Actifs:</h4>
                                                <ul style="list-style-type:square; margin-left:20px;">${servicesHTML || "<li>Aucun détecté</li>"}</ul>
                                                <h4 style="margin-top:10px; color:var(--color-orange-warning); border-bottom:1px dashed var(--color-orange-warning); padding-bottom:3px;">Vulnérabilités Connues:</h4>
                                                <ul style="list-style-type:square; margin-left:20px;">${vulnerabilitiesHTML || "<li>Aucune connue</li>"}</ul>
                                            </div>`;
                                        }, 
                                        { width: '400px', height: 'auto' } 
                                    );
                                }, 1000 + Math.random() * 500); 
                            }
                        });
                    }, {width: '650px', height:'450px'});
                }},
                '/apps/NyxComms.app': {type: 'executable', action: () => openNyxComms()},
                '/apps/EchoPlayer.app': {type: 'executable', action: (args) => openEchoPlayer(args && args[0] ? args[0] : null)},
                '/apps/CognitoDecryptor.app': {type: 'executable', action: () => openCognitoDecryptor()},
                '/echo_fragments/': {type: 'directory', children: ['fragment_alpha.echo', 'fragment_beta.echo', 'fragment_gamma.echo']}, 
                '/echo_fragments/fragment_alpha.echo': { 
                    type: 'echo_file', 
                    /* POGBA: VIDEO_URL_ECHO_ALPHA */
                    videoUrl: 'https://placehold.co/640x360/000000/00FF41.mp4?text=ECHO_ALPHA_VIDEO', 
                    enigma: "Quel est le mot de 4 lettres affiché en rouge à 0:03 dans la vidéo ?",
                    solution: "CODE",
                    unlocksNode: "data_archive_alpha", 
                    nextMessageId: "msg_alpha_solved"
                },
                '/echo_fragments/fragment_beta.echo': {
                    type: 'echo_file',
                    /* POGBA: VIDEO_URL_ECHO_BETA */
                    videoUrl: 'https://placehold.co/640x360/000000/0DFFFF.mp4?text=ECHO_BETA_VIDEO',
                    enigma: "Combien de cercles bleus apparaissent simultanément à la fin de la séquence ?",
                    solution: "3",
                    unlocksNode: "hidden_relay_zeta",
                    nextMessageId: "msg_beta_solved"
                },
                 '/echo_fragments/fragment_gamma.echo': { 
                    type: 'echo_file',
                    /* POGBA: VIDEO_URL_ECHO_GAMMA */
                    videoUrl: 'https://placehold.co/640x360/000000/DA00FF.mp4?text=ECHO_GAMMA_VIDEO',
                    enigma: "Quel est le symbole qui clignote rapidement après le logo CorpX ?",
                    solution: "OMEGA", 
                    unlocksNode: null, 
                    nextMessageId: "msg_gamma_solved"
                },
                '/tools/': {type: 'directory', children: ['PortProbe.tool', 'BasicExploit.sh'], owner: 'nyx_user', permissions: 'rwxr-x---', protected: 1}, 
                '/tools/PortProbe.tool': {
                    type: 'executable',
                    action: (args) => {
                        if (!args[0]) {
                            appendToTerminal("Usage: ./tools/PortProbe.tool <node_id>", "info");
                            return;
                        }
                        const targetNodeKey = args[0];
                        const node = networkNodes[targetNodeKey];
                        if (node) {
                            if (node.locked) {
                                appendToTerminal(`Sondage sur ${targetNodeKey}: ERREUR - Nœud verrouillé ou inaccessible.`, "error");
                                errorSound();
                                return;
                            }
                            appendToTerminal(`<span class="spinner"></span>Sondage des ports sur ${node.label} (${node.ip})...`, "info", true);
                            setTimeout(() => {
                                let foundVuln = false;
                                if (node.vulnerabilities && node.vulnerabilities.length > 0) {
                                    appendToTerminal(`[PortProbe] Rapport pour ${node.label}:`, "info");
                                    node.vulnerabilities.forEach(vuln => {
                                        if (vuln.toLowerCase().includes("port")) {
                                            appendToTerminal(`  <span class="warning">OUVERT:</span> ${vuln}`, "warning", true);
                                            foundVuln = true;
                                        }
                                    });
                                }
                                if (!foundVuln) {
                                    appendToTerminal(`[PortProbe] Aucun port vulnérable évident détecté sur ${node.label}.`, "success");
                                } else {
                                     addNewNyxMessage({
                                        id: `msg_portprobe_${targetNodeKey}_${Date.now()}`, sender: 'Nyx_IntelFeed', subject: `Rapport PortProbe: ${node.label}`, timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), 
                                        body: `Scan de ${node.label} (${node.ip}) terminé.\nDes ports ouverts ont été identifiés (voir terminal).\nUtilisez \`./tools/BasicExploit.sh ${targetNodeKey} <port_ou_mot_cle_vuln>\` pour tenter une intrusion.`, read: false
                                    });
                                }
                                successSound();
                            }, 2000 + Math.random() * 500);
                        } else {
                            appendToTerminal(`Erreur: Nœud cible '${targetNodeKey}' inconnu sur NyxMapper.`, "error");
                            errorSound();
                        }
                    },
                    description: "Sonde les ports d'un nœud réseau identifié."
                },
                '/tools/BasicExploit.sh': {
                    type: 'executable',
                    action: (args) => {
                        if (args.length < 2) {
                            appendToTerminal("Usage: ./tools/BasicExploit.sh <node_id> <port_ou_mot_cle_vuln>", "info");
                            return;
                        }
                        const targetNodeKey = args[0];
                        const exploitArg = args[1]; 
                        const node = networkNodes[targetNodeKey];

                        if (node) {
                            if (node.locked) {
                                appendToTerminal(`Exploit sur ${targetNodeKey}: ERREUR - Nœud verrouillé.`, "error"); errorSound(); return;
                            }
                            appendToTerminal(`<span class="spinner"></span>Tentative d'exploitation de ${node.label} avec '${exploitArg}'...`, "info", true);
                            setTimeout(() => {
                                let exploitSuccess = false;
                                // Logique d'exploit spécifique
                                if (targetNodeKey === 'corp_firewall' && (exploitArg === '8080' || exploitArg.toLowerCase().includes('http-alt') || exploitArg.toLowerCase().includes('cve-2077-001'))) {
                                    exploitSuccess = true;
                                    appendToTerminal(`[BasicExploit] <span class="success">SUCCÈS!</span> Accès partiel obtenu sur ${node.label} via ${exploitArg}.`, "success", true);
                                    addNewNyxMessage({
                                        id: `msg_exploit_corp_${Date.now()}`, sender: 'Nyx_Infiltrator', subject: 'Brèche CorpX Firewall', timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), 
                                        body: `Exploit réussi sur Corp Firewall XG-7 (${exploitArg}).\nUn nouveau fragment d'Écho a été localisé : /echo_fragments/fragment_gamma.echo\nAnalysez-le immédiatement.`, read: false
                                    });
                                    if (fileSystem['/echo_fragments/'] && !fileSystem['/echo_fragments/'].children.includes('fragment_gamma.echo')) {
                                        fileSystem['/echo_fragments/'].children.push('fragment_gamma.echo');
                                    }
                                } else if (targetNodeKey === 'data_archive_alpha' && (exploitArg.toLowerCase().includes('default_password') || exploitArg.toLowerCase().includes('weak_auth'))) {
                                    exploitSuccess = true;
                                    node.status = "Compromis"; // Changer le statut du nœud
                                    appendToTerminal(`[BasicExploit] <span class="success">SUCCÈS!</span> Les identifiants par défaut ont fonctionné sur ${node.label}. Accès aux données obtenu.`, "success", true);
                                    // Simuler la "découverte" d'un fichier
                                    if (!fileSystem['/data/'].children.includes('corp_intel_package.zip')) {
                                        fileSystem['/data/'].children.push('corp_intel_package.zip');
                                        fileSystem['/data/corp_intel_package.zip'] = {type: 'file', content: ["Contenu du package d'intel de CorpX...", "Secrets industriels...", "Plans futurs..."], owner: 'nyx_user', permissions: 'r--------', protected: 2};
                                        appendToTerminal(`[NyxNet] Nouveau fichier découvert : /data/corp_intel_package.zip`, "info");
                                    }
                                    addNewNyxMessage({
                                        id: `msg_exploit_archive_${Date.now()}`, sender: 'Nyx_DataThief', subject: 'Archive CorpX compromise', timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), 
                                        body: `Accès obtenu à Data Archive α.\nLe fichier /data/corp_intel_package.zip contient des données sensibles.\nAnalysez-le. L'Oracle pourrait y avoir laissé une trace.`, read: false
                                    });
                                }
                                
                                if(exploitSuccess) successSound();
                                else {
                                    appendToTerminal(`[BasicExploit] <span class="error">ÉCHEC.</span> L'exploit sur ${node.label} avec '${exploitArg}' n'a pas fonctionné.`, "error", true);
                                    errorSound();
                                }
                            }, 2500 + Math.random() * 1500);
                        } else {
                            appendToTerminal(`Erreur: Nœud cible '${targetNodeKey}' inconnu.`, "error"); errorSound();
                        }
                    },
                    description: "Tente un exploit basique sur un service/port d'un nœud."
                }
            };
            function resolvePath(path, baseDir = currentDirectory) {
                let stack;
                let normalizedBaseDir = baseDir;
                if (normalizedBaseDir !== '/' && !normalizedBaseDir.endsWith('/')) {
                    normalizedBaseDir += '/';
                }

                if (path.startsWith('/')) {
                    stack = []; 
                } else {
                    stack = (normalizedBaseDir === '/') ? [] : normalizedBaseDir.slice(1, -1).split('/');
                }

                const parts = path.split('/');

                for (const part of parts) {
                    if (part === '.' || part === '') continue;
                    if (part === '..') {
                        if (stack.length > 0) stack.pop();
                    } else {
                        stack.push(part);
                    }
                }

                if (stack.length === 0) return '/'; 

                let finalPath = '/' + stack.join('/');
                const potentialDirKey = finalPath + '/';
                if (path.endsWith('/') || (fileSystem[potentialDirKey] && fileSystem[potentialDirKey].type === 'directory')) {
                    if (!finalPath.endsWith('/')) {
                        finalPath += '/';
                    }
                }
                return finalPath;
            } 
            function getNode(path) { return fileSystem[path] || fileSystem[path+'/'] ; } 

            function updatePrompt() { if(promptElement) promptElement.innerHTML = `<span class="text-cyan-bright">${currentUser}@nyx-os</span>:<span class="text-purple-bright">${currentDirectory}</span>$&nbsp;`; }
            function appendToTerminal(text, type = '', html = false) {
                if (!terminalOutput) return;
                const p = document.createElement('div');
                p.className = type; 
                if (html) p.innerHTML = text; else p.textContent = text;
                terminalOutput.appendChild(p);
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
            }
            function attemptLogin(args) {
                 if (args[0] === 'nyx_user' && args[1] === 'veil') { 
                    currentUser = 'nyx_user'; accessLevel = 1; loginSound();
                    updatePrompt(); appendToTerminal("Accès autorisé: nyx_user", "success");
                    if(userStatusEl) userStatusEl.textContent = `USER: ${currentUser}`;
                    addNewNyxMessage({
                        id: `msg_tool_grant_${Date.now()}`, sender: 'Nyx_Quartermaster', subject: 'Dotation Initiale', timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), 
                        body: "Opérateur,\n\nL'outil de sondage de ports standard `PortProbe.tool` a été ajouté à votre répertoire /tools/.\nUtilisez-le pour examiner les nœuds accessibles sur NyxMapper.\nSyntaxe: ./tools/PortProbe.tool <id_du_noeud>\n\nUn second outil, `BasicExploit.sh`, est également disponible pour tenter des intrusions ciblées.\nSyntaxe: ./tools/BasicExploit.sh <id_du_noeud> <port_ou_mot_cle_vuln>\n\nBonne chasse.", read: false
                    });
                    if (!fileSystem['/tools/']) {
                        fileSystem['/tools/'] = { type: 'directory', children: ['PortProbe.tool', 'BasicExploit.sh'], owner: 'nyx_user', permissions: 'rwxr-x---', protected: 1 };
                        if (fileSystem['/'] && !fileSystem['/'].children.includes('tools/')) {
                            fileSystem['/'].children.push('tools/');
                        }
                    } else { 
                         if (!fileSystem['/tools/'].children.includes('BasicExploit.sh')) {
                            fileSystem['/tools/'].children.push('BasicExploit.sh');
                         }
                    }

                } else { errorSound(); appendToTerminal("Échec authentification.", "error"); }
            }
            
            // --- Logique des nouvelles applications ---
            function openEchoPlayer(filePath) {
                let nodeToPlay;
                if (filePath) {
                    const resolvedPath = resolvePath(filePath, currentDirectory);
                    nodeToPlay = getNode(resolvedPath);
                }

                if (nodeToPlay && nodeToPlay.type === 'echo_file') {
                    currentEcho = nodeToPlay; 
                    const echoFileName = filePath.split('/').pop(); 
                    windowManager.createWindow(`echo-player-${echoFileName}`, `Echo Player - ${echoFileName}`, (contentDiv) => {
                        const videoId = `echo-video-${Date.now()}`; 
                        const buttonId = `open-decryptor-btn-${Date.now()}`; 
                        contentDiv.innerHTML = `
                            <video id="${videoId}" class="echo-player-video" controls autoplay>
                                <source src="${nodeToPlay.videoUrl}" type="video/mp4">
                                Votre navigateur ne supporte pas la balise vidéo ou le format de la vidéo est incorrect.
                            </video>
                            <div class="echo-player-controls">
                                <p class="info text-sm mb-2">Indice/Question: ${nodeToPlay.enigma || "Analysez attentivement cet Écho."}</p>
                                <button id="${buttonId}" class="echo-player-controls button">Ouvrir Cognito Decryptor</button>
                            </div>`;
                        const videoElement = contentDiv.querySelector(`#${videoId}`);
                        videoElement.onerror = () => {
                            contentDiv.querySelector('.echo-player-controls').insertAdjacentHTML('afterbegin', '<p class="error">Erreur: Impossible de charger la vidéo. Vérifiez l\'URL.</p>');
                        };
                        contentDiv.querySelector(`#${buttonId}`).onclick = () => openCognitoDecryptor(nodeToPlay, echoFileName);
                    }, { width: '680px', height: 'auto' });
                } else if (filePath) {
                    appendToTerminal(`Erreur: '${filePath}' n'est pas un fichier Écho valide. Utilisez 'open /chemin/vers/fichier.echo'`, "error");
                } else {
                     appendToTerminal("Usage: open <chemin_vers_fichier.echo>", "info");
                }
            }
            function openCognitoDecryptor(echoData = null, echoName = "Inconnu") {
                const targetEcho = echoData || currentEcho; 

                windowManager.createWindow('cognito-decryptor', `Cognito Decryptor`, (contentDiv) => {
                    const inputId = `decryptor-input-${Date.now()}`;
                    const resultId = `decryptor-result-${Date.now()}`;
                    const buttonId = `decryptor-submit-btn-${Date.now()}`;

                    contentDiv.innerHTML = `
                        <p class="info text-sm mb-1">${targetEcho ? `Décryptage pour Écho: ${echoName}` : "Aucun Écho actif."}</p>
                        <p class="text-xs mb-3">${targetEcho ? (targetEcho.enigma || "Entrez la solution de l'Écho.") : "Ouvrez un Écho en premier via la commande 'open'."}</p>
                        <input type="text" id="${inputId}" class="cognito-decryptor-input" placeholder="Solution...">
                        <button id="${buttonId}" class="cognito-decryptor-button">SOUMETTRE ANALYSE</button>
                        <div id="${resultId}" class="mt-3 text-sm"></div>
                    `;
                    
                    contentDiv.querySelector(`#${buttonId}`).onclick = () => {
                        const solutionInput = contentDiv.querySelector(`#${inputId}`).value;
                        const resultDiv = contentDiv.querySelector(`#${resultId}`);
                        if (targetEcho) {
                            if (solutionInput.trim().toUpperCase() === targetEcho.solution.toUpperCase()) {
                                resultDiv.innerHTML = '<p class="success">SOLUTION CORRECTE. Nouvelles données potentiellement débloquées.</p>';
                                successSound();
                                appendToTerminal(`[Cognito] Solution pour ${echoName} acceptée.`, "success");
                                
                                if (targetEcho.unlocksNode && networkNodes[targetEcho.unlocksNode]) {
                                    networkNodes[targetEcho.unlocksNode].locked = false;
                                    networkNodes[targetEcho.unlocksNode].status = 'Online'; 
                                    appendToTerminal(`[NyxMapper] Accès au nœud '${networkNodes[targetEcho.unlocksNode].label}' déverrouillé.`, "success");
                                    const mapperCanvas = document.getElementById('nyx-mapper-canvas');
                                    if(mapperCanvas) drawNyxMapper(mapperCanvas);
                                }
                                if (targetEcho.nextMessageId) {
                                    const messagesToAdd = {
                                        "msg_alpha_solved": { id: `msg_alpha_solved_${Date.now()}`, sender: 'Nyx_Admin', subject: 'Progression : Archive Alpha', timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), body: "Bien joué, Opérateur.\nL'analyse de l'Écho Alpha a permis de localiser l'archive de données 'Data Archive α'.\nElle est maintenant accessible sur NyxMapper.\nUtilisez PortProbe.tool pour examiner ses vulnérabilités.", read: false },
                                        "msg_beta_solved": {id: `msg_beta_solved_${Date.now()}`, sender: "Unknown_Contact", subject: "Le Relais Zeta...", timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), body: "Le Relais Zeta est de nouveau en ligne grâce à vous... mais pour combien de temps ?\nDes signaux étranges en émanent. Soyez prudent.", read: false},
                                        "msg_gamma_solved": {id: `msg_gamma_solved_${Date.now()}`, sender: "Nyx_OracleAI_Fragment", subject: "Fragment Gamma Analysé", timestamp: new Date().toLocaleTimeString('fr-FR', {hour12:false}), body: "Symbole OMEGA identifié.\nCeci est une pièce maîtresse du puzzle de l'Oracle.\nDe nouvelles directives suivront. Restez vigilant.", read: false}
                                    };
                                    if(messagesToAdd[targetEcho.nextMessageId]) {
                                        addNewNyxMessage(messagesToAdd[targetEcho.nextMessageId]);
                                    }
                                }
                            } else {
                                resultDiv.innerHTML = '<p class="error">SOLUTION INCORRECTE. Tentative enregistrée.</p>';
                                errorSound();
                            }
                        } else {
                            resultDiv.innerHTML = '<p class="warning">Veuillez ouvrir un Écho en premier via la commande "open".</p>';
                        }
                    };
                }, { width: '420px', height: '280px' });
            }
            
            // --- NyxComms Logic ---
            const nyxMessages = [
                { id: 'msg001', sender: 'Nyx_Admin', subject: 'Bienvenue, Opérateur', timestamp: '2077.10.26_02:33', body: "Vos identifiants ont été validés.\nVotre première tâche : localiser et analyser l'Écho Alpha.\nIl se trouve dans /echo_fragments/fragment_alpha.echo\nUtilisez la commande 'open' pour le visionner.\n\nLe Voile observe.", read: false },
                { id: 'msg002', sender: 'Unknown_Contact', subject: 'AVERTISSEMENT URGENT', timestamp: '2077.10.25_18:05', body: "Ils savent que vous cherchez.\nL'Oracle n'est pas mort, il est fragmenté.\nChaque Écho est une clé, mais aussi un piège.\nMéfiez-vous des ombres que vous ne projetez pas.\n\nIndice pour le pare-feu CorpX : cherchez les ports non standards souvent utilisés pour le débogage HTTP.\nIl est visible sur NyxMapper, mais son accès direct est... compliqué.\n\n- Un Ami (ou pas)", read: false },
                { id: 'msg003', sender: 'Nyx_TechSupport', subject: 'Rapport Système : Module IA', timestamp: '2077.10.26_09:15', body: "Le module d'analyse NyxCore_AI est actuellement hors-ligne pour maintenance.\nLes analyses d'Échos devront être effectuées manuellement via CognitoDecryptor.\nNous travaillons à sa réintégration.\n\n- Support Technique NyxNet", read: true }
            ];
            let hasUnreadMessages = nyxMessages.some(msg => !msg.read);

            function updateCommsIndicator() {
                if (commsIndicatorEl) {
                    hasUnreadMessages = nyxMessages.some(msg => !msg.read);
                    if (hasUnreadMessages) {
                        commsIndicatorEl.classList.add('new-message');
                    } else {
                        commsIndicatorEl.classList.remove('new-message');
                    }
                }
            }
            
            function addNewNyxMessage(newMessage) {
                nyxMessages.unshift(newMessage); 
                updateCommsIndicator();
                const commsWindowContent = windowManager.getWindowContent('window-nyx-comms');
                if (commsWindowContent) {
                    const listPanel = commsWindowContent.querySelector('#message-list-panel');
                    const viewPanel = commsWindowContent.querySelector('#message-view-panel');
                    if (listPanel && viewPanel) { 
                         renderMessageListInComms(listPanel, viewPanel); 
                    }
                }
                successSound(); 
            }
            
            function renderMessageListInComms(listPanel, viewPanel) { 
                listPanel.innerHTML = ''; 
                nyxMessages.sort((a,b) => (a.read === b.read) ? 0 : a.read ? 1 : -1); 
                nyxMessages.forEach(msg => {
                    const msgItem = document.createElement('div');
                    msgItem.className = 'message-item';
                    msgItem.classList.toggle('unread', !msg.read);
                    msgItem.classList.toggle('read', msg.read);
                    
                    msgItem.innerHTML = `
                        <span class="message-sender">${msg.sender}</span>
                        <span class="message-subject">${msg.subject}</span>
                        <span class="message-timestamp">${msg.timestamp}</span>
                    `;
                    
                    msgItem.onclick = () => {
                        document.querySelectorAll('#message-list-panel .message-item.selected').forEach(el => el.classList.remove('selected'));
                        msgItem.classList.add('selected');
                        msgItem.classList.remove('unread');
                        msgItem.classList.add('read');
                        msg.read = true;
                        updateCommsIndicator();

                        viewPanel.innerHTML = `
                            <h4>De: ${msg.sender}</h4>
                            <p style="font-size:0.8em; opacity:0.7; margin-bottom:10px;">Sujet: ${msg.subject}<br>Date: ${msg.timestamp}</p>
                            <div class="message-body">${msg.body.replace(/\n/g, '<br>')}</div>
                        `;
                    };
                    listPanel.appendChild(msgItem);
                });
            }


            function openNyxComms() {
                windowManager.createWindow('nyx-comms', 'NyxComms v0.3', (contentDiv) => {
                    contentDiv.innerHTML = `
                        <div class="nyx-comms-container">
                            <div id="message-list-panel" class="message-list-panel"></div>
                            <div id="message-view-panel" class="message-view-panel">
                                <p class="info">Sélectionnez un message pour le lire.</p>
                            </div>
                        </div>`;
                    const listPanel = contentDiv.querySelector('#message-list-panel');
                    const viewPanel = contentDiv.querySelector('#message-view-panel');
                    renderMessageListInComms(listPanel, viewPanel); 
                    updateCommsIndicator(); 
                }, {width: '700px', height: '500px'});
            }


            async function handleCommand(cmd) {
                const [command, ...args] = cmd.trim().split(' ');
                if (terminalOutput && promptElement) appendToTerminal(`${promptElement.textContent}${cmd}`);
                keyClickSound();

                if (command.startsWith('./')) {
                    const scriptPath = resolvePath(command.substring(2), currentDirectory);
                    const scriptNode = getNode(scriptPath);
                    if (scriptNode && scriptNode.type === 'executable') {
                        if (scriptNode.action) { 
                           await scriptNode.action(args); 
                        } else {
                            appendToTerminal(`Erreur: Action non définie pour le script '${command.substring(2)}'.`, "error");
                        }
                    } else {
                        appendToTerminal(`Script non trouvé ou non exécutable: ${command.substring(2)}`, "error");
                    }
                    return;
                }
                switch(command.toLowerCase()){
                    case 'help': appendToTerminal("Commandes: ls, cd, cat, ./login.sh, apps, open <fichier.echo>, clear, help, music on/off", "info"); break;
                    case 'ls': 
                        const nodeLs = getNode(currentDirectory);
                        if (nodeLs && nodeLs.type === 'directory') {
                            appendToTerminal(`Contenu de ${currentDirectory}:`, 'info');
                            nodeLs.children.forEach(c => appendToTerminal(c));
                        } else appendToTerminal("Erreur: Chemin invalide", "error");
                        break;
                    case 'cd': 
                         if (!args[0]) { appendToTerminal("Usage: cd <répertoire>", "info"); break;}
                         const newPath = resolvePath(args[0], currentDirectory);
                         const targetNodeCd = getNode(newPath);
                         if (targetNodeCd && targetNodeCd.type === 'directory') { currentDirectory = newPath; updatePrompt();}
                         else { appendToTerminal(`Répertoire non trouvé: ${args[0]}`, "error");}
                        break;
                    case 'cat': 
                        if (!args[0]) { appendToTerminal("Usage: cat <fichier>", "info"); break;}
                        const filePathCat = resolvePath(args[0], currentDirectory);
                        const fileNodeCat = getNode(filePathCat);
                        if (fileNodeCat && fileNodeCat.type === 'file') appendToTerminal(fileNodeCat.content.join('\n'));
                        else { appendToTerminal(`Fichier non trouvé: ${args[0]}`, "error");}
                        break;
                    case 'apps': 
                        appendToTerminal("Applications disponibles dans /apps/:", "info");
                        const appsNode = getNode('/apps/');
                        if (appsNode && appsNode.children) {
                            appsNode.children.forEach(app => appendToTerminal(`  ${app} (exécuter avec ./apps/${app})`));
                        }
                        break;
                    case 'open': 
                        if (args[0]) openEchoPlayer(args[0]);
                        else appendToTerminal("Usage: open <chemin_vers_fichier.echo>", "info");
                        break;
                    case 'clear': if(terminalOutput) terminalOutput.innerHTML = ""; break;
                    case 'music':
                        if (args[0] === 'on') startBackgroundMusic();
                        else if (args[0] === 'off') stopBackgroundMusic();
                        else appendToTerminal("Usage: music [on|off]", "info");
                        break;
                    default: appendToTerminal(`Commande inconnue: ${command}`, "error"); errorSound();
                }
            }

            // --- Séquence de Boot ---
            const bootMessages = [
                { text: "INIT NYX_KERNEL_V3.0...", delay: 200, progress: 10 },
                { text: "MEMORY CHECK...........OK", delay: 300, progress: 25 },
                { text: "LOADING CORE MODULES...", delay: 500, progress: 50 },
                { text: "ORACLE ECHO HANDLER....ONLINE", delay: 400, progress: 65, type: 'success'},
                { text: "ENCRYPTION LAYER.......ACTIVE", delay: 300, progress: 75 },
                { text: "NYXOS 'ORACLE ECHOES' ONLINE", delay: 200, progress: 100, type: 'success' }
            ];
            async function runBootSequence(messages) {
                for (let i = 0; i < messages.length; i++) {
                    const msg = messages[i];
                    if (bootTextEl) {
                        const p = document.createElement('p');
                        if (msg.type) p.className = msg.type;
                        p.textContent = msg.text;
                        bootTextEl.appendChild(p);
                    }
                    if (bootProgressBarEl) bootProgressBarEl.style.width = `${msg.progress}%`;
                    await new Promise(resolve => setTimeout(resolve, msg.delay));
                }
                setTimeout(() => {
                    if (bootScreenEl) bootScreenEl.style.display = 'none';
                    if (desktopEl) desktopEl.style.display = 'flex'; 
                    windowManager.createWindow('nyx-terminal', 'NyxTerm v3.0', (contentDiv) => {
                        contentDiv.innerHTML = `<div id="terminal-output"></div><div class="prompt-line"><span id="prompt"></span><input type="text" id="terminal-input" class="terminal-input" spellcheck="false" autofocus/></div>`;
                        terminalOutput = contentDiv.querySelector('#terminal-output');
                        terminalInput = contentDiv.querySelector('#terminal-input');
                        promptElement = contentDiv.querySelector('#prompt');
                        appendToTerminal("Bienvenue sur NyxOS v3.0. Tapez 'help' pour les commandes.", "info");
                        updatePrompt();
                        terminalInput.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                const command = terminalInput.value;
                                if (command.trim() !== "") commandHistory.unshift(command);
                                historyIndex = -1;
                                handleCommand(command);
                                terminalInput.value = '';
                            } 
                        });
                    }, { width: '70%', height: '70%' });
                    updateCommsIndicator(); 
                }, 300);
            }
            runBootSequence(bootMessages);

            // --- Horloge et Status ---
            function updateHeaderFooter() {
                if (nyxClockEl) nyxClockEl.textContent = new Date().toLocaleTimeString('fr-FR');
                if (userStatusEl && currentUser) userStatusEl.textContent = `USER: ${currentUser} (LVL: ${accessLevel})`;
            }
            setInterval(updateHeaderFooter, 1000);
            updateHeaderFooter(); 
            
            document.body.addEventListener('click', async () => { if (Tone.context.state !== 'running') await Tone.start(); }, { once: true });
        };
    </script>
</body>
</html>
